function Result$Err$0$(param0) {
  this._0 = param0;
}
Result$Err$0$.prototype.$tag = 0;
function Result$Ok$0$(param0) {
  this._0 = param0;
}
Result$Ok$0$.prototype.$tag = 1;
function Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError.prototype.$tag = 15;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__type_Rule_$46$YYObj__immut_list_T__type_Rule_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__type_Rule_$46$YYObj__immut_list_T__type_Rule_.prototype.$tag = 14;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Rule$46$YYObj__type_Rule(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Rule$46$YYObj__type_Rule.prototype.$tag = 13;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj___type_Regex___type_CodeBlock_$46$YYObj___type_Regex___type_CodeBlock_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj___type_Regex___type_CodeBlock_$46$YYObj___type_Regex___type_CodeBlock_.prototype.$tag = 12;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__.prototype.$tag = 11;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String___type_Regex_$46$YYObj__String___type_Regex_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String___type_Regex_$46$YYObj__String___type_Regex_.prototype.$tag = 10;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T.prototype.$tag = 9;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex.prototype.$tag = 8;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__String___type_Regex__$46$YYObj__immut_list_T__String___type_Regex__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__String___type_Regex__$46$YYObj__immut_list_T__String___type_Regex__.prototype.$tag = 7;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Lex$46$YYObj__type_Lex(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Lex$46$YYObj__type_Lex.prototype.$tag = 6;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Char$46$YYObj_Char(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Char$46$YYObj_Char.prototype.$tag = 5;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String.prototype.$tag = 4;
function Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_.prototype.$tag = 3;
const Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void = { $tag: 2 };
function Error$moonbitlang$47$lex$47$lib$47$parser$46$ParseError$46$UnexpectedToken(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
Error$moonbitlang$47$lex$47$lib$47$parser$46$ParseError$46$UnexpectedToken.prototype.$tag = 1;
function Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError.prototype.$tag = 0;
const $9223372036854775807L = { hi: 2147483647, lo: -1 };
const $10L = { hi: 0, lo: 10 };
const $1L = { hi: 0, lo: 1 };
const $16L = { hi: 0, lo: 16 };
const $_9223372036854775808L = { hi: -2147483648, lo: 0 };
function Result$Err$1$(param0) {
  this._0 = param0;
}
Result$Err$1$.prototype.$tag = 0;
function Result$Ok$1$(param0) {
  this._0 = param0;
}
Result$Ok$1$.prototype.$tag = 1;
function Result$Err$2$(param0) {
  this._0 = param0;
}
Result$Err$2$.prototype.$tag = 0;
function Result$Ok$2$(param0) {
  this._0 = param0;
}
Result$Ok$2$.prototype.$tag = 1;
function Result$Err$3$(param0) {
  this._0 = param0;
}
Result$Err$3$.prototype.$tag = 0;
function Result$Ok$3$(param0) {
  this._0 = param0;
}
Result$Ok$3$.prototype.$tag = 1;
const $0L = { hi: 0, lo: 0 };
function $compare_int(a, b) {
  return (a >= b) - (a <= b);
}
function $make_array_len_and_init(a, b) {
  const arr = new Array(a);
  for (let i = 0; i < a; i++) {
    arr[i] = b;
  }
  return arr;
}
const moonbitlang$core$array$$JSArray$copy = (arr) => arr.slice(0);
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$4$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$4$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$4$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$5$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$5$.prototype.$tag = 1;
function $i32_popcnt(a) {
  a = a - ((a >>> 1) & 0x55555555);
  a = (a & 0x33333333) + ((a >>> 2) & 0x33333333);
  a = (a + (a >>> 4)) & 0x0f0f0f0f;
  a = a + (a >>> 8);
  a = a + (a >>> 16);
  return a & 0x3f;
}
const $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$6$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$6$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$6$.prototype.$tag = 1;
class $PanicError extends Error {}
function $panic() {
  throw new $PanicError();
}
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$7$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$8$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$8$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$8$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$8$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$8$.prototype.$tag = 3;
const $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$9$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$9$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$9$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$9$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$9$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$9$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$9$.prototype.$tag = 3;
const Option$None$10$ = { $tag: 0 };
function Option$Some$10$(param0) {
  this._0 = param0;
}
Option$Some$10$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$8$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$8$.prototype.$tag = 0;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$9$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$9$.prototype.$tag = 0;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$11$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$11$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$11$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$11$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$11$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$11$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$11$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$11$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$11$.prototype.$tag = 4;
const $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$queue$46$Cell$Cons$12$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$queue$46$Cell$Cons$12$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$queue$46$Cell$Cons$13$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$queue$46$Cell$Cons$13$.prototype.$tag = 1;
const Option$None$14$ = { $tag: 0 };
function Option$Some$14$(param0) {
  this._0 = param0;
}
Option$Some$14$.prototype.$tag = 1;
const moonbitlang$core$builtin$$JSArray$push = (arr, val) => { arr.push(val); };
const moonbitlang$core$builtin$$JSArray$pop = (arr) => arr.pop();
const moonbitlang$core$builtin$$get_int64_wasm_helper = function f() {   if (f._exports) return f._exports;   return f._exports = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports; };
const moonbitlang$core$builtin$$MyInt64$compare = (a, b) => {   const ahi = a.hi;   const bhi = b.hi;   if (ahi < bhi) {     return -1;   }   if (ahi > bhi) {     return 1;   }   const alo = a.lo >>> 0;   const blo = b.lo >>> 0;   if (alo < blo) {     return -1;   }   if (alo > blo) {     return 1;   }   return 0; };
const $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ = { $tag: 0 };
function $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Node$15$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Node$15$.prototype.$tag = 1;
const $64$moonbitlang$47$lex$47$lib$47$util$47$eof_char_set$46$EofCharRepr$Eof = { $tag: 0 };
function $64$moonbitlang$47$lex$47$lib$47$util$47$eof_char_set$46$EofCharRepr$Char(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$util$47$eof_char_set$46$EofCharRepr$Char.prototype.$tag = 1;
const $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Underscore = { $tag: 0 };
const $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$EOF = { $tag: 1 };
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReStr(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReStr.prototype.$tag = 2;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReChar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReChar.prototype.$tag = 3;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$CharSet(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$CharSet.prototype.$tag = 4;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Repetition(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Repetition.prototype.$tag = 5;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Option(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Option.prototype.$tag = 6;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Alter(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Alter.prototype.$tag = 7;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Concat(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Concat.prototype.$tag = 8;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Capture(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Capture.prototype.$tag = 9;
function $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Named(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Named.prototype.$tag = 10;
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EOI = { $tag: 0 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EOF = { $tag: 1 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$PARSE_LBRACE = { $tag: 2 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LET = { $tag: 3 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$AS = { $tag: 4 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$UNDERSCORE = { $tag: 5 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RBRACE = { $tag: 6 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LPAREN = { $tag: 7 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RPAREN = { $tag: 8 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LBRACKET = { $tag: 9 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RBRACKET = { $tag: 10 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EQ = { $tag: 11 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$SEMICOLON = { $tag: 12 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$FAT_ARROW = { $tag: 13 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$BAR = { $tag: 14 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$STAR = { $tag: 15 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$PLUS = { $tag: 16 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$QUESTION = { $tag: 17 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$MINUS = { $tag: 18 };
const $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CARET = { $tag: 19 };
function $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE.prototype.$tag = 20;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE.prototype.$tag = 21;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LC_IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LC_IDENT.prototype.$tag = 22;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR.prototype.$tag = 23;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$STRING(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$Token$STRING.prototype.$tag = 24;
function Result$Err$16$(param0) {
  this._0 = param0;
}
Result$Err$16$.prototype.$tag = 0;
function Result$Ok$16$(param0) {
  this._0 = param0;
}
Result$Ok$16$.prototype.$tag = 1;
function Result$Err$17$(param0) {
  this._0 = param0;
}
Result$Err$17$.prototype.$tag = 0;
function Result$Ok$17$(param0) {
  this._0 = param0;
}
Result$Ok$17$.prototype.$tag = 1;
const $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead.prototype.$tag = 3;
const $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error = { $tag: 4 };
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$18$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$18$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$18$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$19$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$19$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$19$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$20$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$20$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$20$.prototype.$tag = 1;
const $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps = { $tag: 0 };
function $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar.prototype.$tag = 1;
function $64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$StartPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$StartPosOf.prototype.$tag = 0;
function $64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$EndPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$EndPosOf.prototype.$tag = 1;
function $64$Yoorkin$47$ArgParser$46$Spec$Unit(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Unit.prototype.$tag = 0;
function $64$Yoorkin$47$ArgParser$46$Spec$String(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$String.prototype.$tag = 1;
function $64$Yoorkin$47$ArgParser$46$Spec$Set_string(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set_string.prototype.$tag = 2;
function $64$Yoorkin$47$ArgParser$46$Spec$Set(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set.prototype.$tag = 3;
function $64$Yoorkin$47$ArgParser$46$Spec$Clear(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Clear.prototype.$tag = 4;
const moonbitlang$x$sys$internal$ffi$$get_cli_args_internal = function() {   return process.argv;  };
const moonbitlang$x$fs$$read_file_ffi = function(path) {    var fs = require('fs');    try {      const content = fs.readFileSync(path);      globalThis.fileContent = content;      return 0;    } catch (error) {      globalThis.errorMessage = error.message;      return -1;    }  };
const moonbitlang$x$fs$$write_file_ffi = function(path, content) {    var fs = require('fs');    try {      fs.writeFileSync(path, Buffer.from(content));      return 0;    } catch (error) {      globalThis.errorMessage = error.message;      return -1;    }  };
const moonbitlang$x$fs$$get_file_content_ffi = function() {    return globalThis.fileContent;  };
const moonbitlang$x$fs$$get_error_message_ffi = function() {    return globalThis.errorMessage || '';  };
function Result$Err$21$(param0) {
  this._0 = param0;
}
Result$Err$21$.prototype.$tag = 0;
function Result$Ok$21$(param0) {
  this._0 = param0;
}
Result$Ok$21$.prototype.$tag = 1;
function Result$Err$22$(param0) {
  this._0 = param0;
}
Result$Err$22$.prototype.$tag = 0;
function Result$Ok$22$(param0) {
  this._0 = param0;
}
Result$Ok$22$.prototype.$tag = 1;
function Result$Err$23$(param0) {
  this._0 = param0;
}
Result$Err$23$.prototype.$tag = 0;
function Result$Ok$23$(param0) {
  this._0 = param0;
}
Result$Ok$23$.prototype.$tag = 1;
function Result$Err$24$(param0) {
  this._0 = param0;
}
Result$Err$24$.prototype.$tag = 0;
function Result$Ok$24$(param0) {
  this._0 = param0;
}
Result$Ok$24$.prototype.$tag = 1;
function Result$Err$25$(param0) {
  this._0 = param0;
}
Result$Err$25$.prototype.$tag = 0;
function Result$Ok$25$(param0) {
  this._0 = param0;
}
Result$Ok$25$.prototype.$tag = 1;
function Result$Err$26$(param0) {
  this._0 = param0;
}
Result$Err$26$.prototype.$tag = 0;
function Result$Ok$26$(param0) {
  this._0 = param0;
}
Result$Ok$26$.prototype.$tag = 1;
const moonbitlang$core$strconv$$base_err_str = "invalid base";
const moonbitlang$core$strconv$$range_err_str = "value out of range";
const moonbitlang$core$strconv$$syntax_err_str = "invalid syntax";
const moonbitlang$core$immut$internal$sparse_array$$empty_bitset = 0;
const moonbitlang$lex$lib$parser$$token_tag_action_row_0 = [];
const moonbitlang$lex$lib$parser$$token_tag_action_row_1 = [-1];
const moonbitlang$lex$lib$parser$$token_tag_action_row_2 = [0];
const moonbitlang$lex$lib$parser$$token_tag_action_row_4 = [1];
const moonbitlang$lex$lib$parser$$token_tag_action_row_3 = [-1, 0];
const moonbitlang$lex$lib$parser$$token_tag_action_row_5 = [0, 1];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0 = [];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1 = [0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2 = [-1];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0 = [];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1 = [0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2 = [-1];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0 = [];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2 = [-1];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1 = [0];
const moonbitlang$lex$main$$_init$42$46$usage$0$ = "Usage: moonlex [options] <input-file>";
const moonbitlang$lex$45$runtime$lexbuf$$string_lexbuf_class = { next: moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$next, curr_pos: moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$curr_pos, reset: moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$reset, sub_lexeme: moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$sub_lexeme };
const moonbitlang$lex$lib$util$eof_char_set$$eof = moonbitlang$lex$lib$util$diet$$singleton$1$(moonbitlang$lex$lib$util$eof_char_set$$EofChar$eof());
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_11 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_10 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_6 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_4 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_12 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_2 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_3 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_7 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_2, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_9 = [moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_1, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0, moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_row_0];
const moonbitlang$lex$lib$parser$$__mbtlex_engine_string_inner_rquote = { graph: [moonbitlang$lex$lib$parser$$string_inner_rquote_state_0, moonbitlang$lex$lib$parser$$string_inner_rquote_state_1, moonbitlang$lex$lib$parser$$string_inner_rquote_state_2, moonbitlang$lex$lib$parser$$string_inner_rquote_state_3, moonbitlang$lex$lib$parser$$string_inner_rquote_state_4, moonbitlang$lex$lib$parser$$string_inner_rquote_state_5, moonbitlang$lex$lib$parser$$string_inner_rquote_state_6, moonbitlang$lex$lib$parser$$string_inner_rquote_state_7, moonbitlang$lex$lib$parser$$string_inner_rquote_state_8, moonbitlang$lex$lib$parser$$string_inner_rquote_state_9, moonbitlang$lex$lib$parser$$string_inner_rquote_state_10, moonbitlang$lex$lib$parser$$string_inner_rquote_state_11, moonbitlang$lex$lib$parser$$string_inner_rquote_state_12, moonbitlang$lex$lib$parser$$string_inner_rquote_state_13, moonbitlang$lex$lib$parser$$string_inner_rquote_state_14, moonbitlang$lex$lib$parser$$string_inner_rquote_state_15, moonbitlang$lex$lib$parser$$string_inner_rquote_state_16, moonbitlang$lex$lib$parser$$string_inner_rquote_state_17, moonbitlang$lex$lib$parser$$string_inner_rquote_state_18, moonbitlang$lex$lib$parser$$string_inner_rquote_state_19, moonbitlang$lex$lib$parser$$string_inner_rquote_state_20, moonbitlang$lex$lib$parser$$string_inner_rquote_state_21, moonbitlang$lex$lib$parser$$string_inner_rquote_state_22, moonbitlang$lex$lib$parser$$string_inner_rquote_state_23, moonbitlang$lex$lib$parser$$string_inner_rquote_state_24, moonbitlang$lex$lib$parser$$string_inner_rquote_state_25], end_nodes: [undefined, { _0: 11, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, { _0: 12, _1: [] }, { _0: 11, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, { _0: 0, _1: [] }, { _0: 7, _1: [] }, { _0: 1, _1: [] }, { _0: 5, _1: [] }, undefined, { _0: 4, _1: [] }, { _0: 2, _1: [] }, { _0: 6, _1: [] }, { _0: 3, _1: [] }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, { _0: 8, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, undefined, undefined, { _0: 10, _1: [{ _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }] }, undefined, { _0: 9, _1: [{ _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }] }], start_tags: [6], code_blocks_n: 13 };
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_6 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_8 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_4 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_0 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_2 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_3 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_10 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$code_rbrace_tag_action_9 = [moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$lex$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$parser$$__mbtlex_engine_code_rbrace = { graph: [moonbitlang$lex$lib$parser$$code_rbrace_state_0, moonbitlang$lex$lib$parser$$code_rbrace_state_1, moonbitlang$lex$lib$parser$$code_rbrace_state_2, moonbitlang$lex$lib$parser$$code_rbrace_state_3, moonbitlang$lex$lib$parser$$code_rbrace_state_4, moonbitlang$lex$lib$parser$$code_rbrace_state_5, moonbitlang$lex$lib$parser$$code_rbrace_state_6, moonbitlang$lex$lib$parser$$code_rbrace_state_7, moonbitlang$lex$lib$parser$$code_rbrace_state_8, moonbitlang$lex$lib$parser$$code_rbrace_state_9, moonbitlang$lex$lib$parser$$code_rbrace_state_10, moonbitlang$lex$lib$parser$$code_rbrace_state_11, moonbitlang$lex$lib$parser$$code_rbrace_state_12, moonbitlang$lex$lib$parser$$code_rbrace_state_13, moonbitlang$lex$lib$parser$$code_rbrace_state_14, moonbitlang$lex$lib$parser$$code_rbrace_state_15, moonbitlang$lex$lib$parser$$code_rbrace_state_16], end_nodes: [undefined, { _0: 6, _1: [] }, { _0: 3, _1: [] }, { _0: 4, _1: [] }, { _0: 5, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, undefined, undefined, undefined, undefined, { _0: 1, _1: [{ _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }] }, undefined, { _0: 2, _1: [{ _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }] }, undefined, { _0: 0, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }], start_tags: [0, 2, 4, 6], code_blocks_n: 7 };
const moonbitlang$lex$lib$parser$$token_tag_action_3 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1];
const moonbitlang$lex$lib$parser$$token_tag_action_9 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_0 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_23 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_3, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_18 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_24 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_20 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_12 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_2 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_1 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_15 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_11 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_4 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_19 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_3, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_8 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_13 = [moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_17 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_7 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_6 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_10 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_5 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_16 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_1, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_14 = [moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_21 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_5, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_3, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$token_tag_action_22 = [moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_4, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_2, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0, moonbitlang$lex$lib$parser$$token_tag_action_row_0];
const moonbitlang$lex$lib$parser$$__mbtlex_engine_token = { graph: [moonbitlang$lex$lib$parser$$token_state_0, moonbitlang$lex$lib$parser$$token_state_1, moonbitlang$lex$lib$parser$$token_state_2, moonbitlang$lex$lib$parser$$token_state_3, moonbitlang$lex$lib$parser$$token_state_4, moonbitlang$lex$lib$parser$$token_state_5, moonbitlang$lex$lib$parser$$token_state_6, moonbitlang$lex$lib$parser$$token_state_7, moonbitlang$lex$lib$parser$$token_state_8, moonbitlang$lex$lib$parser$$token_state_9, moonbitlang$lex$lib$parser$$token_state_10, moonbitlang$lex$lib$parser$$token_state_11, moonbitlang$lex$lib$parser$$token_state_12, moonbitlang$lex$lib$parser$$token_state_13, moonbitlang$lex$lib$parser$$token_state_14, moonbitlang$lex$lib$parser$$token_state_15, moonbitlang$lex$lib$parser$$token_state_16, moonbitlang$lex$lib$parser$$token_state_17, moonbitlang$lex$lib$parser$$token_state_18, moonbitlang$lex$lib$parser$$token_state_19, moonbitlang$lex$lib$parser$$token_state_20, moonbitlang$lex$lib$parser$$token_state_21, moonbitlang$lex$lib$parser$$token_state_22, moonbitlang$lex$lib$parser$$token_state_23, moonbitlang$lex$lib$parser$$token_state_24, moonbitlang$lex$lib$parser$$token_state_25, moonbitlang$lex$lib$parser$$token_state_26, moonbitlang$lex$lib$parser$$token_state_27, moonbitlang$lex$lib$parser$$token_state_28, moonbitlang$lex$lib$parser$$token_state_29, moonbitlang$lex$lib$parser$$token_state_30, moonbitlang$lex$lib$parser$$token_state_31, moonbitlang$lex$lib$parser$$token_state_32, moonbitlang$lex$lib$parser$$token_state_33, moonbitlang$lex$lib$parser$$token_state_34, moonbitlang$lex$lib$parser$$token_state_35, moonbitlang$lex$lib$parser$$token_state_36, moonbitlang$lex$lib$parser$$token_state_37, moonbitlang$lex$lib$parser$$token_state_38, moonbitlang$lex$lib$parser$$token_state_39, moonbitlang$lex$lib$parser$$token_state_40, moonbitlang$lex$lib$parser$$token_state_41, moonbitlang$lex$lib$parser$$token_state_42, moonbitlang$lex$lib$parser$$token_state_43, moonbitlang$lex$lib$parser$$token_state_44, moonbitlang$lex$lib$parser$$token_state_45, moonbitlang$lex$lib$parser$$token_state_46, moonbitlang$lex$lib$parser$$token_state_47, moonbitlang$lex$lib$parser$$token_state_48, moonbitlang$lex$lib$parser$$token_state_49, moonbitlang$lex$lib$parser$$token_state_50, moonbitlang$lex$lib$parser$$token_state_51, moonbitlang$lex$lib$parser$$token_state_52, moonbitlang$lex$lib$parser$$token_state_53, moonbitlang$lex$lib$parser$$token_state_54, moonbitlang$lex$lib$parser$$token_state_55, moonbitlang$lex$lib$parser$$token_state_56, moonbitlang$lex$lib$parser$$token_state_57, moonbitlang$lex$lib$parser$$token_state_58, moonbitlang$lex$lib$parser$$token_state_59, moonbitlang$lex$lib$parser$$token_state_60, moonbitlang$lex$lib$parser$$token_state_61, moonbitlang$lex$lib$parser$$token_state_62, moonbitlang$lex$lib$parser$$token_state_63, moonbitlang$lex$lib$parser$$token_state_64, moonbitlang$lex$lib$parser$$token_state_65, moonbitlang$lex$lib$parser$$token_state_66, moonbitlang$lex$lib$parser$$token_state_67, moonbitlang$lex$lib$parser$$token_state_68, moonbitlang$lex$lib$parser$$token_state_69, moonbitlang$lex$lib$parser$$token_state_70, moonbitlang$lex$lib$parser$$token_state_71, moonbitlang$lex$lib$parser$$token_state_72, moonbitlang$lex$lib$parser$$token_state_73, moonbitlang$lex$lib$parser$$token_state_74, moonbitlang$lex$lib$parser$$token_state_75, moonbitlang$lex$lib$parser$$token_state_76, moonbitlang$lex$lib$parser$$token_state_77, moonbitlang$lex$lib$parser$$token_state_78, moonbitlang$lex$lib$parser$$token_state_79, moonbitlang$lex$lib$parser$$token_state_80, moonbitlang$lex$lib$parser$$token_state_81, moonbitlang$lex$lib$parser$$token_state_82, moonbitlang$lex$lib$parser$$token_state_83], end_nodes: [undefined, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 0, _1: [] }, { _0: 35, _1: [] }, undefined, { _0: 23, _1: [] }, { _0: 22, _1: [] }, { _0: 21, _1: [] }, { _0: 20, _1: [] }, { _0: 19, _1: [] }, { _0: 18, _1: [] }, { _0: 17, _1: [] }, { _0: 15, _1: [] }, { _0: 14, _1: [] }, { _0: 13, _1: [] }, { _0: 12, _1: [] }, { _0: 11, _1: [] }, { _0: 10, _1: [] }, { _0: 9, _1: [] }, { _0: 16, _1: [] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 2, _1: [] }, undefined, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, undefined, undefined, { _0: 8, _1: [] }, { _0: 7, _1: [] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 1, _1: [] }, { _0: 24, _1: [{ _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }] }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, { _0: 6, _1: [] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 3, _1: [] }, { _0: 1, _1: [] }, { _0: 1, _1: [] }, { _0: 31, _1: [] }, { _0: 27, _1: [] }, { _0: 30, _1: [] }, { _0: 29, _1: [] }, { _0: 28, _1: [] }, { _0: 26, _1: [] }, undefined, { _0: 25, _1: [] }, undefined, undefined, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, undefined, undefined, undefined, { _0: 36, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, undefined, { _0: 32, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, undefined, undefined, undefined, { _0: 5, _1: [] }, undefined, undefined, { _0: 34, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }] }, undefined, undefined, { _0: 33, _1: [{ _0: { _0: 8, _1: 0 }, _1: { _0: 9, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }, { _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }] }, undefined, undefined], start_tags: [12], code_blocks_n: 37 };
const moonbitlang$lex$lib$util$eof_char_set$$empty = moonbitlang$lex$lib$util$diet$$empty$1$();
const moonbitlang$lex$lib$util$eof_char_set$$any = moonbitlang$lex$lib$util$eof_char_set$$range(0, 1114111);
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_3 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_7 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_1 = [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_2, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_row_0];
const moonbitlang$lex$lib$codegen$internal$codeblock_parser$$__mbtlex_engine_scan_codeblock_rbrace = { graph: [moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_0, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_1, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_2, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_3, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_4, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_5, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_6, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_7, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_8, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_9, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_10, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_11, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_12, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_13, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_14, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_15, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_16, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_17, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_18, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_19, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_20, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_21, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_22, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_23, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_24, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_25, moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_26], end_nodes: [{ _0: 5, _1: [] }, { _0: 4, _1: [] }, { _0: 4, _1: [] }, { _0: 1, _1: [] }, { _0: 0, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, { _0: 3, _1: [] }, undefined, { _0: 3, _1: [] }, undefined, undefined, { _0: 3, _1: [] }, undefined, undefined, { _0: 2, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }, { _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }, { _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }] }], start_tags: [0], code_blocks_n: 6 };
function moonbitlang$core$strconv$$base_err$2$() {
  return new Result$Err$0$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$base_err_str));
}
function moonbitlang$core$strconv$$check_and_consume_base(view, base) {
  let rest;
  _L: {
    let rest$2;
    _L$2: {
      let rest$3;
      _L$3: {
        let rest$4;
        _L$4: {
          if (moonbitlang$core$string$$StringView$length_ge(view, 2)) {
            const _x = moonbitlang$core$string$$StringView$op_get(view, 0);
            if (_x === 48) {
              const _x$2 = moonbitlang$core$string$$StringView$op_get(view, 1);
              switch (_x$2) {
                case 120: {
                  const _x$3 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$4 = _x$3;
                  break _L$4;
                }
                case 88: {
                  const _x$4 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$4 = _x$4;
                  break _L$4;
                }
                case 111: {
                  const _x$5 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$3 = _x$5;
                  break _L$3;
                }
                case 79: {
                  const _x$6 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$3 = _x$6;
                  break _L$3;
                }
                case 98: {
                  const _x$7 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$2 = _x$7;
                  break _L$2;
                }
                case 66: {
                  const _x$8 = moonbitlang$core$string$$StringView$op_as_view(view, 2, undefined);
                  rest$2 = _x$8;
                  break _L$2;
                }
                default: {
                  rest = view;
                  break _L;
                }
              }
            } else {
              rest = view;
              break _L;
            }
          } else {
            rest = view;
            break _L;
          }
        }
        _L$5: {
          switch (base) {
            case 0: {
              break _L$5;
            }
            case 16: {
              break _L$5;
            }
            default: {
              return moonbitlang$core$strconv$$base_err$2$();
            }
          }
        }
        return new Result$Ok$0$({ _0: 16, _1: rest$4, _2: true });
      }
      _L$4: {
        switch (base) {
          case 0: {
            break _L$4;
          }
          case 8: {
            break _L$4;
          }
          default: {
            return moonbitlang$core$strconv$$base_err$2$();
          }
        }
      }
      return new Result$Ok$0$({ _0: 8, _1: rest$3, _2: true });
    }
    _L$3: {
      switch (base) {
        case 0: {
          break _L$3;
        }
        case 2: {
          break _L$3;
        }
        default: {
          return moonbitlang$core$strconv$$base_err$2$();
        }
      }
    }
    return new Result$Ok$0$({ _0: 2, _1: rest$2, _2: true });
  }
  if (base === 0) {
    return new Result$Ok$0$({ _0: 10, _1: rest, _2: false });
  } else {
    return 2 <= base && base <= 36 ? new Result$Ok$0$({ _0: base, _1: rest, _2: false }) : moonbitlang$core$strconv$$base_err$2$();
  }
}
function moonbitlang$core$strconv$$overflow_threshold(base, neg) {
  return !neg ? (base === 10 ? moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, $10L), $1L) : base === 16 ? moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, $16L), $1L) : moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, moonbitlang$core$int$$Int$to_int64(base)), $1L)) : base === 10 ? moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, $10L) : base === 16 ? moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, $16L) : moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, moonbitlang$core$int$$Int$to_int64(base));
}
function moonbitlang$core$strconv$$range_err$3$() {
  return new Result$Err$1$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$range_err$4$() {
  return new Result$Err$2$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$syntax_err$3$() {
  return new Result$Err$1$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$5$() {
  return new Result$Err$3$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$parse_int64(str, base) {
  if (moonbitlang$core$builtin$$op_notequal$6$(str, "")) {
    let _bind;
    let rest;
    _L: {
      _L$2: {
        const _bind$2 = moonbitlang$core$string$$String$op_as_view(str, moonbitlang$core$string$$String$op_as_view$46$start$46$default(), undefined);
        if (moonbitlang$core$string$$StringView$length_ge(_bind$2, 1)) {
          const _x = moonbitlang$core$string$$StringView$op_get(_bind$2, 0);
          switch (_x) {
            case 43: {
              const _x$2 = moonbitlang$core$string$$StringView$op_as_view(_bind$2, 1, undefined);
              _bind = { _0: false, _1: _x$2 };
              break;
            }
            case 45: {
              const _x$3 = moonbitlang$core$string$$StringView$op_as_view(_bind$2, 1, undefined);
              _bind = { _0: true, _1: _x$3 };
              break;
            }
            default: {
              rest = _bind$2;
              break _L$2;
            }
          }
        } else {
          rest = _bind$2;
          break _L$2;
        }
        break _L;
      }
      _bind = { _0: false, _1: rest };
    }
    const _x = _bind._0;
    const _x$2 = _bind._1;
    const _bind$2 = moonbitlang$core$strconv$$check_and_consume_base(_x$2, base);
    let _bind$3;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _bind$3 = _ok._0;
    } else {
      return _bind$2;
    }
    const _x$3 = _bind$3._0;
    const _x$4 = _bind$3._1;
    const _x$5 = _bind$3._2;
    const overflow_threshold = moonbitlang$core$strconv$$overflow_threshold(_x$3, _x);
    let has_digit;
    if (moonbitlang$core$string$$StringView$length_ge(_x$4, 1)) {
      const _x$6 = moonbitlang$core$string$$StringView$op_get(_x$4, 0);
      if (48 <= _x$6 && _x$6 <= 57) {
        has_digit = true;
      } else {
        if (97 <= _x$6 && _x$6 <= 122) {
          has_digit = true;
        } else {
          if (65 <= _x$6 && _x$6 <= 90) {
            has_digit = true;
          } else {
            if (moonbitlang$core$string$$StringView$length_ge(_x$4, 2)) {
              if (_x$6 === 95) {
                const _x$7 = moonbitlang$core$string$$StringView$op_get(_x$4, 1);
                has_digit = 48 <= _x$7 && _x$7 <= 57 ? true : 97 <= _x$7 && _x$7 <= 122 ? true : 65 <= _x$7 && _x$7 <= 90;
              } else {
                has_digit = false;
              }
            } else {
              has_digit = false;
            }
          }
        }
      }
    } else {
      has_digit = false;
    }
    if (has_digit) {
      let _tmp;
      let _tmp$2 = _x$4;
      let _tmp$3 = $0L;
      let _tmp$4 = _x$5;
      while (true) {
        const _param = _tmp$2;
        const _param$2 = _tmp$3;
        const _param$3 = _tmp$4;
        let acc;
        let rest$2;
        let c;
        _L$2: {
          if (moonbitlang$core$string$$StringView$length_eq(_param, 1)) {
            const _x$6 = moonbitlang$core$string$$StringView$op_get(_param, 0);
            if (_x$6 === 95) {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$3$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            } else {
              const _x$7 = moonbitlang$core$string$$StringView$op_as_view(_param, 1, undefined);
              acc = _param$2;
              rest$2 = _x$7;
              c = _x$6;
              break _L$2;
            }
          } else {
            if (moonbitlang$core$string$$StringView$length_ge(_param, 1)) {
              const _x$6 = moonbitlang$core$string$$StringView$op_get(_param, 0);
              if (_x$6 === 95) {
                if (_param$3 === false) {
                  const _bind$4 = moonbitlang$core$strconv$$syntax_err$3$();
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    _tmp = _ok._0;
                    break;
                  } else {
                    return _bind$4;
                  }
                } else {
                  const _x$7 = moonbitlang$core$string$$StringView$op_as_view(_param, 1, undefined);
                  _tmp$2 = _x$7;
                  _tmp$4 = false;
                  continue;
                }
              } else {
                const _x$7 = moonbitlang$core$string$$StringView$op_as_view(_param, 1, undefined);
                acc = _param$2;
                rest$2 = _x$7;
                c = _x$6;
                break _L$2;
              }
            } else {
              _tmp = _param$2;
              break;
            }
          }
        }
        let d;
        if (48 <= c && c <= 57) {
          d = moonbitlang$core$char$$Char$op_sub(c, 48);
        } else {
          if (97 <= c && c <= 122) {
            d = moonbitlang$core$char$$Char$op_sub(c, 97) + 10 | 0;
          } else {
            if (65 <= c && c <= 90) {
              d = moonbitlang$core$char$$Char$op_sub(c, 65) + 10 | 0;
            } else {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$5$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                d = _ok._0;
              } else {
                return _bind$4;
              }
            }
          }
        }
        if (d < _x$3) {
          if (_x) {
            if (moonbitlang$core$builtin$$op_ge$3$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$int64$$Int64$op_sub(moonbitlang$core$int64$$Int64$op_mul(acc, moonbitlang$core$int$$Int$to_int64(_x$3)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$op_le$3$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$3$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$3$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          } else {
            if (moonbitlang$core$builtin$$op_lt$3$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_mul(acc, moonbitlang$core$int$$Int$to_int64(_x$3)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$op_ge$3$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$3$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$3$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          }
        } else {
          const _bind$4 = moonbitlang$core$strconv$$syntax_err$3$();
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp = _ok._0;
            break;
          } else {
            return _bind$4;
          }
        }
      }
      return new Result$Ok$1$(_tmp);
    } else {
      return moonbitlang$core$strconv$$syntax_err$3$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$3$();
  }
}
function moonbitlang$core$strconv$$parse_int(str, base) {
  const _bind = moonbitlang$core$strconv$$parse_int64(str, base);
  let n;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    n = _ok._0;
  } else {
    return _bind;
  }
  if (moonbitlang$core$builtin$$op_lt$3$(n, moonbitlang$core$int$$Int$to_int64(-2147483648)) || moonbitlang$core$builtin$$op_gt$3$(n, moonbitlang$core$int$$Int$to_int64(2147483647))) {
    const _bind$2 = moonbitlang$core$strconv$$range_err$4$();
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
  }
  return new Result$Ok$3$(moonbitlang$core$int64$$Int64$to_int(n));
}
function moonbitlang$core$bytes$$Bytes$from_array(arr) {
  return moonbitlang$core$bytes$$Bytes$makei(arr.length, (i) => moonbitlang$core$array$$Array$op_get$7$(arr, i));
}
function moonbitlang$core$string$$is_leading_surrogate(c) {
  return 55296 <= c && c <= 56319;
}
function moonbitlang$core$string$$is_trailing_surrogate(c) {
  return 56320 <= c && c <= 57343;
}
function moonbitlang$core$string$$String$index_at(self, offset_by, start) {
  const str_len = self.length;
  if (start >= 0 && start <= str_len) {
    let utf16_offset = start;
    let char_count = 0;
    while (true) {
      if (utf16_offset < str_len && char_count < offset_by) {
        const c1 = self.charCodeAt(utf16_offset);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (utf16_offset + 1 | 0) < str_len) {
          const c2 = self.charCodeAt(utf16_offset + 1 | 0);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            utf16_offset = utf16_offset + 2 | 0;
            char_count = char_count + 1 | 0;
            continue;
          } else {
            moonbitlang$core$builtin$$abort$4$("invalid surrogate pair");
          }
        }
        utf16_offset = utf16_offset + 1 | 0;
        char_count = char_count + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return char_count < offset_by || utf16_offset > str_len ? undefined : utf16_offset;
  } else {
    return moonbitlang$core$builtin$$abort$8$("Invalid start index");
  }
}
function moonbitlang$core$string$$String$index_at_rev(self, offset_by, end) {
  const str_len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = str_len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x >= 0 && _x <= str_len ? _x : moonbitlang$core$builtin$$abort$5$("Invalid end index");
  }
  let utf16_offset = end$2;
  let char_count = 0;
  while (true) {
    if (utf16_offset > 0 && char_count < offset_by) {
      const c1 = self.charCodeAt(utf16_offset - 1 | 0);
      if (moonbitlang$core$string$$is_trailing_surrogate(c1) && (utf16_offset - 2 | 0) >= 0) {
        const c2 = self.charCodeAt(utf16_offset - 2 | 0);
        if (moonbitlang$core$string$$is_leading_surrogate(c2)) {
          utf16_offset = utf16_offset - 2 | 0;
          char_count = char_count + 1 | 0;
          continue;
        }
      }
      utf16_offset = utf16_offset - 1 | 0;
      char_count = char_count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return char_count < offset_by || utf16_offset < 0 ? undefined : utf16_offset;
}
function moonbitlang$core$string$$StringView$length_eq(self, len) {
  let _tmp = self.start;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const self_len = _tmp$2;
    if (index < self.end && self_len < len) {
      const c1 = self.str.charCodeAt(index);
      if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < self.end) {
        const c2 = self.str.charCodeAt(index + 1 | 0);
        if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
          const _tmp$3 = index + 2 | 0;
          const _tmp$4 = self_len + 1 | 0;
          _tmp = _tmp$3;
          _tmp$2 = _tmp$4;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$4$("invalid surrogate pair");
        }
      }
      const _tmp$3 = index + 1 | 0;
      const _tmp$4 = self_len + 1 | 0;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return self_len === len && index === self.end;
    }
  }
}
function moonbitlang$core$string$$StringView$length_ge(self, len) {
  let _tmp = self.start;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const self_len = _tmp$2;
    if (index < self.end && self_len < len) {
      const c1 = self.str.charCodeAt(index);
      if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < self.end) {
        const c2 = self.str.charCodeAt(index + 1 | 0);
        if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
          const _tmp$3 = index + 2 | 0;
          const _tmp$4 = self_len + 1 | 0;
          _tmp = _tmp$3;
          _tmp$2 = _tmp$4;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$4$("invalid surrogate pair");
        }
      }
      const _tmp$3 = index + 1 | 0;
      const _tmp$4 = self_len + 1 | 0;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return self_len >= len;
    }
  }
}
function moonbitlang$core$string$$String$op_as_view(self, start, end) {
  const str_len = self.length;
  const start$2 = start >= 0 ? moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at(self, start, 0)) : moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at_rev(self, -start, str_len));
  let end$2;
  if (end === undefined) {
    end$2 = str_len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x >= 0 ? moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at(self, _x, 0)) : moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at_rev(self, -_x, str_len));
  }
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= str_len) ? { str: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$10$("Invalid index for View");
}
function moonbitlang$core$string$$String$op_as_view$46$start$46$default() {
  return 0;
}
function moonbitlang$core$string$$StringView$op_as_view(self, start, end) {
  const start$2 = start >= 0 ? moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at(self.str, start, self.start)) : moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at_rev(self.str, -start, self.end));
  let end$2;
  if (end === undefined) {
    end$2 = self.end;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x >= 0 ? moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at(self.str, _x, self.start)) : moonbitlang$core$option$$Option$unwrap$9$(moonbitlang$core$string$$String$index_at_rev(self.str, -_x, self.end));
  }
  return start$2 >= self.start && (start$2 <= self.end && (end$2 >= self.start && (end$2 <= self.end && start$2 <= end$2))) ? { str: self.str, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$10$("Invalid index for View");
}
function moonbitlang$core$string$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$StringView$op_get(self, index) {
  if (index >= 0) {
    let utf16_offset = self.start;
    let char_count = 0;
    const code_unit_length = self.str.length;
    while (true) {
      if (char_count < index && utf16_offset < self.end) {
        const c1 = self.str.charCodeAt(utf16_offset);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (utf16_offset + 1 | 0) < code_unit_length) {
          const c2 = self.str.charCodeAt(utf16_offset + 1 | 0);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            utf16_offset = utf16_offset + 2 | 0;
            char_count = char_count + 1 | 0;
            continue;
          } else {
            moonbitlang$core$builtin$$abort$4$("invalid surrogate pair");
          }
        }
        utf16_offset = utf16_offset + 1 | 0;
        char_count = char_count + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (char_count === index && utf16_offset < self.end) {
      const c1 = self.str.charCodeAt(utf16_offset);
      if (moonbitlang$core$string$$is_leading_surrogate(c1)) {
        const c2 = self.str.charCodeAt(utf16_offset + 1 | 0);
        return moonbitlang$core$string$$is_trailing_surrogate(c2) ? moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2) : moonbitlang$core$builtin$$abort$11$("invalid surrogate pair");
      } else {
        return c1;
      }
    } else {
      return moonbitlang$core$builtin$$abort$11$(`Index out of bounds: cannot access index ${moonbitlang$core$builtin$$Show$to_string$5$(index)}`);
    }
  } else {
    return moonbitlang$core$builtin$$abort$11$("Index out of bounds: cannot access negative index");
  }
}
function moonbitlang$core$string$$String$from_array(chars) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(Math.imul(chars.length, 4) | 0);
  const _len = chars.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const c = chars[_i];
      moonbitlang$core$builtin$$Logger$write_char$12$(buf, c);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$string$$String$concat(strings, separator) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  if (separator === "") {
    const _len = strings.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const s = strings[_i];
        moonbitlang$core$builtin$$Logger$write_string$12$(buf, s);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  } else {
    if (strings.length === 0) {
    } else {
      const _x = moonbitlang$core$array$$Array$op_get$6$(strings, 0);
      const _x$2 = moonbitlang$core$array$$Array$op_as_view$6$(strings, 1, strings.length - 0 | 0);
      moonbitlang$core$builtin$$Logger$write_string$12$(buf, _x);
      const _len = moonbitlang$core$array$$ArrayView$length$6$(_x$2);
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const s = _x$2.buf[_x$2.start + _i | 0];
          moonbitlang$core$builtin$$Logger$write_string$12$(buf, separator);
          moonbitlang$core$builtin$$Logger$write_string$12$(buf, s);
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$builtin$$Compare$compare$6$(self, other) {
  const len = self.length;
  const _bind = $compare_int(len, other.length);
  if (_bind === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const order = $compare_int(self.charCodeAt(i), other.charCodeAt(i));
        if (order !== 0) {
          return order;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 0;
  } else {
    return _bind;
  }
}
function moonbitlang$core$string$$String$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$11$((yield_) => {
    const len = self.length;
    let _tmp = 0;
    while (true) {
      const index = _tmp;
      if (index < len) {
        const c1 = self.charCodeAt(index);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < len) {
          const c2 = self.charCodeAt(index + 1 | 0);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            const c = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
            const _bind = yield_(c);
            if (_bind === 1) {
              _tmp = index + 2 | 0;
              continue;
            } else {
              return 0;
            }
          }
        }
        const _bind = yield_(c1);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = index + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$string$$String$to_array(self) {
  const _bind = moonbitlang$core$string$$String$iter(self);
  const _bind$2 = moonbitlang$core$array$$Array$new$11$(self.length);
  const _acc = { val: _bind$2 };
  _bind((_p) => {
    const rv = _acc.val;
    moonbitlang$core$array$$Array$push$11$(rv, _p);
    _acc.val = rv;
    return 1;
  });
  return _acc.val;
}
function moonbitlang$core$result$$Result$unwrap$13$(self) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _x = _Ok._0;
    return _x;
  } else {
    return moonbitlang$core$builtin$$abort$5$("called `Result::unwrap()` on an `Err` value");
  }
}
function moonbitlang$core$result$$Result$unwrap$14$(self) {
  if (self.$tag === 1) {
    const _Ok = self;
    _Ok._0;
    return;
  } else {
    moonbitlang$core$builtin$$abort$4$("called `Result::unwrap()` on an `Err` value");
    return;
  }
}
function moonbitlang$core$result$$Result$unwrap$15$(self) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _x = _Ok._0;
    return _x;
  } else {
    return moonbitlang$core$builtin$$abort$6$("called `Result::unwrap()` on an `Err` value");
  }
}
function moonbitlang$core$sorted_set$$new$5$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_set$$height$5$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_set$$height_ge$5$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_set$$max(x, y) {
  return x > y ? x : y;
}
function moonbitlang$core$sorted_set$$Node$update_height$5$(self) {
  self.height = 1 + moonbitlang$core$sorted_set$$max(moonbitlang$core$sorted_set$$height$5$(self.left), moonbitlang$core$sorted_set$$height$5$(self.right)) | 0;
}
function moonbitlang$core$sorted_set$$rotate_l$5$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$16$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$5$(n);
  moonbitlang$core$sorted_set$$Node$update_height$5$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_r$5$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$16$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$5$(n);
  moonbitlang$core$sorted_set$$Node$update_height$5$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_lr$5$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$16$(n.left);
  const v = moonbitlang$core$sorted_set$$rotate_l$5$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$5$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$5$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$16$(n.right);
  const v = moonbitlang$core$sorted_set$$rotate_r$5$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$5$(n);
}
function moonbitlang$core$sorted_set$$balance$5$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_set$$height$5$(l);
  const hr = moonbitlang$core$sorted_set$$height$5$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$16$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$5$(_x, _x$2) ? moonbitlang$core$sorted_set$$rotate_r$5$(root) : moonbitlang$core$sorted_set$$rotate_lr$5$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$16$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$5$(_x$2, _x) ? moonbitlang$core$sorted_set$$rotate_l$5$(root) : moonbitlang$core$sorted_set$$rotate_rl$5$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$5$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$new_node$5$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$46$left$46$default$5$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$right$46$default$5$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$height$46$default$5$() {
  return 1;
}
function moonbitlang$core$sorted_set$$add_node$5$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$5$(value, moonbitlang$core$sorted_set$$new_node$46$left$46$default$5$(), moonbitlang$core$sorted_set$$new_node$46$right$46$default$5$(), moonbitlang$core$sorted_set$$new_node$46$height$46$default$5$()), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    const comp = $compare_int(value, _x.value);
    if (comp === 0) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$5$(l, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$5$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$5$(r, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$5$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$T$add$5$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$5$(self.root, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$17$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$T$to_array$5$(self) {
  if (self.size === 0) {
    return [];
  } else {
    const padding = moonbitlang$core$option$$Option$unwrap$16$(self.root).value;
    const arr = moonbitlang$core$array$$Array$make$5$(self.size, padding);
    const i = { val: 0 };
    const _env = { _0: arr, _1: i };
    moonbitlang$core$sorted_set$$to_array$46$dfs$47$235(_env, self.root);
    return arr;
  }
}
function moonbitlang$core$sorted_set$$to_array$46$dfs$47$235(_env, root) {
  const i = _env._1;
  const arr = _env._0;
  if (root === undefined) {
  } else {
    const _Some = root;
    const _x = _Some;
    moonbitlang$core$sorted_set$$to_array$46$dfs$47$235(_env, _x.left);
    moonbitlang$core$array$$Array$op_set$5$(arr, i.val, _x.value);
    i.val = i.val + 1 | 0;
    moonbitlang$core$sorted_set$$to_array$46$dfs$47$235(_env, _x.right);
  }
}
function moonbitlang$core$sorted_set$$from_iter$5$(iter) {
  const s = moonbitlang$core$sorted_set$$new$5$();
  iter((_p) => {
    moonbitlang$core$sorted_set$$T$add$5$(s, _p);
    return 1;
  });
  return s;
}
function moonbitlang$core$builtin$$Eq$op_equal$18$(self, other) {
  return self.value === other.value;
}
function moonbitlang$core$ref$$new$6$(x) {
  return { val: x };
}
function moonbitlang$core$array$$get_limit(len) {
  let len$2 = len;
  let limit = 0;
  while (true) {
    if (len$2 > 0) {
      len$2 = len$2 / 2 | 0;
      limit = limit + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return limit;
}
function moonbitlang$core$array$$ArrayView$rev_inplace$6$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$6$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$6$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$6$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$19$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$19$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$19$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$19$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$choose_pivot$6$(arr) {
  const len = moonbitlang$core$array$$ArrayView$length$6$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$268(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$268(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$268(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot$46$sort_3$47$268(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$6$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot$46$sort_2$47$267(_env, a, b) {
  const arr = _env._1;
  const swaps = _env._0;
  if (moonbitlang$core$builtin$$op_gt$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, a), moonbitlang$core$array$$ArrayView$op_get$6$(arr, b))) {
    moonbitlang$core$array$$ArrayView$swap$6$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot$46$sort_3$47$268(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$267(_env, a, b);
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$267(_env, b, c);
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$267(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot$19$(arr) {
  const len = moonbitlang$core$array$$ArrayView$length$19$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: swaps, _1: arr };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$286(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$286(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot$46$sort_3$47$286(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot$46$sort_3$47$286(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$19$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot$46$sort_2$47$285(_env, a, b) {
  const arr = _env._1;
  const swaps = _env._0;
  if (moonbitlang$core$builtin$$op_gt$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, a), moonbitlang$core$array$$ArrayView$op_get$19$(arr, b))) {
    moonbitlang$core$array$$ArrayView$swap$19$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot$46$sort_3$47$286(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$285(_env, a, b);
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$285(_env, b, c);
  moonbitlang$core$array$$choose_pivot$46$sort_2$47$285(_env, a, b);
}
function moonbitlang$core$array$$sift_down$6$(arr, index) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$6$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && moonbitlang$core$builtin$$op_lt$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, child), moonbitlang$core$array$$ArrayView$op_get$6$(arr, child + 1 | 0))) {
        child = child + 1 | 0;
      }
      if (moonbitlang$core$builtin$$op_ge$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$6$(arr, child))) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$6$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down$19$(arr, index) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$19$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && moonbitlang$core$builtin$$op_lt$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, child), moonbitlang$core$array$$ArrayView$op_get$19$(arr, child + 1 | 0))) {
        child = child + 1 | 0;
      }
      if (moonbitlang$core$builtin$$op_ge$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$19$(arr, child))) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$19$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort$6$(arr) {
  const len = moonbitlang$core$array$$ArrayView$length$6$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down$6$(arr, i);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$6$(arr, 0, i);
      moonbitlang$core$array$$sift_down$6$(moonbitlang$core$array$$ArrayView$op_as_view$6$(arr, 0, i), 0);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort$19$(arr) {
  const len = moonbitlang$core$array$$ArrayView$length$19$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down$19$(arr, i);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$19$(arr, 0, i);
      moonbitlang$core$array$$sift_down$19$(moonbitlang$core$array$$ArrayView$op_as_view$19$(arr, 0, i), 0);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$minimum(x, y) {
  return x > y ? y : x;
}
function moonbitlang$core$array$$partition$6$(arr, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$6$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$6$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$6$(arr, moonbitlang$core$array$$ArrayView$length$6$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < (moonbitlang$core$array$$ArrayView$length$6$(arr) - 1 | 0)) {
      if (moonbitlang$core$builtin$$op_lt$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, j), pivot)) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$6$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$6$(arr, i, moonbitlang$core$array$$ArrayView$length$6$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition$19$(arr, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$19$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$19$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$19$(arr, moonbitlang$core$array$$ArrayView$length$19$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < (moonbitlang$core$array$$ArrayView$length$19$(arr) - 1 | 0)) {
      if (moonbitlang$core$builtin$$op_lt$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, j), pivot)) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$19$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$19$(arr, i, moonbitlang$core$array$$ArrayView$length$19$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$try_bubble_sort$6$(arr) {
  let tries = 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$6$(arr)) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && moonbitlang$core$builtin$$op_gt$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$6$(arr, j))) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$6$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort$19$(arr) {
  let tries = 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$19$(arr)) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && moonbitlang$core$builtin$$op_gt$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$19$(arr, j))) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$19$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$ArrayView$insertion_sort$6$(arr) {
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$6$(arr)) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && moonbitlang$core$builtin$$op_gt$6$(moonbitlang$core$array$$ArrayView$op_get$6$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$6$(arr, j))) {
          moonbitlang$core$array$$ArrayView$swap$6$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$insertion_sort$19$(arr) {
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$19$(arr)) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && moonbitlang$core$builtin$$op_gt$19$(moonbitlang$core$array$$ArrayView$op_get$19$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$19$(arr, j))) {
          moonbitlang$core$array$$ArrayView$swap$19$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$quick_sort$6$(arr, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$6$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$ArrayView$insertion_sort$6$(arr$2);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort$6$(arr$2);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot$6$(arr$2);
    const _x = _bind._0;
    const _x$2 = _bind._1;
    if (was_partitioned && (balanced && _x$2)) {
      if (moonbitlang$core$array$$try_bubble_sort$6$(arr$2)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition$6$(arr$2, _x);
    const _x$3 = _bind$2._0;
    const _x$4 = _bind$2._1;
    was_partitioned = _x$4;
    balanced = moonbitlang$core$array$$minimum(_x$3, len - _x$3 | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _x$5 = _Some;
      if (_x$5 === moonbitlang$core$array$$ArrayView$op_get$6$(arr$2, _x$3)) {
        let i = _x$3;
        while (true) {
          if (i < len && _x$5 === moonbitlang$core$array$$ArrayView$op_get$6$(arr$2, i)) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$6$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$6$(arr$2, 0, _x$3);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$6$(arr$2, _x$3 + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$6$(left) < moonbitlang$core$array$$ArrayView$length$6$(right)) {
      moonbitlang$core$array$$quick_sort$6$(left, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$6$(arr$2, _x$3);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort$6$(right, moonbitlang$core$array$$ArrayView$op_get$6$(arr$2, _x$3), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort$19$(arr, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$19$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$ArrayView$insertion_sort$19$(arr$2);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort$19$(arr$2);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot$19$(arr$2);
    const _x = _bind._0;
    const _x$2 = _bind._1;
    if (was_partitioned && (balanced && _x$2)) {
      if (moonbitlang$core$array$$try_bubble_sort$19$(arr$2)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition$19$(arr$2, _x);
    const _x$3 = _bind$2._0;
    const _x$4 = _bind$2._1;
    was_partitioned = _x$4;
    balanced = moonbitlang$core$array$$minimum(_x$3, len - _x$3 | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _x$5 = _Some;
      if (moonbitlang$core$builtin$$Eq$op_equal$20$(_x$5, moonbitlang$core$array$$ArrayView$op_get$19$(arr$2, _x$3))) {
        let i = _x$3;
        while (true) {
          if (i < len && moonbitlang$core$builtin$$Eq$op_equal$20$(_x$5, moonbitlang$core$array$$ArrayView$op_get$19$(arr$2, i))) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$19$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$19$(arr$2, 0, _x$3);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$19$(arr$2, _x$3 + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$19$(left) < moonbitlang$core$array$$ArrayView$length$19$(right)) {
      moonbitlang$core$array$$quick_sort$19$(left, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$19$(arr$2, _x$3);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort$19$(right, moonbitlang$core$array$$ArrayView$op_get$19$(arr$2, _x$3), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$Array$sort$6$(self) {
  const len = self.length;
  moonbitlang$core$array$$quick_sort$6$(moonbitlang$core$array$$Array$op_as_view$6$(self, moonbitlang$core$array$$Array$op_as_view$46$start$46$default$6$(), len), undefined, moonbitlang$core$array$$get_limit(len));
}
function moonbitlang$core$array$$Array$sort$19$(self) {
  const len = self.length;
  moonbitlang$core$array$$quick_sort$19$(moonbitlang$core$array$$Array$op_as_view$19$(self, moonbitlang$core$array$$Array$op_as_view$46$start$46$default$19$(), len), undefined, moonbitlang$core$array$$get_limit(len));
}
function moonbitlang$core$array$$Array$makei$21$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = moonbitlang$core$array$$Array$make$21$(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        moonbitlang$core$array$$Array$op_set$21$(array, i, value(i));
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$Array$makei$6$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = moonbitlang$core$array$$Array$make$6$(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        moonbitlang$core$array$$Array$op_set$6$(array, i, value(i));
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$Array$makei$22$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = moonbitlang$core$array$$Array$make$22$(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        moonbitlang$core$array$$Array$op_set$22$(array, i, value(i));
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$copy$23$(self) {
  const len = self.length;
  if (len === 0) {
    return [];
  } else {
    const arr = $make_array_len_and_init(len, self[0]);
    moonbitlang$core$array$$FixedArray$unsafe_blit$23$(arr, 0, self, 0, len);
    return arr;
  }
}
function moonbitlang$core$array$$FixedArray$copy$24$(self) {
  const len = self.length;
  if (len === 0) {
    return [];
  } else {
    const arr = $make_array_len_and_init(len, self[0]);
    moonbitlang$core$array$$FixedArray$unsafe_blit$24$(arr, 0, self, 0, len);
    return arr;
  }
}
function moonbitlang$core$array$$FixedArray$copy$5$(self) {
  const len = self.length;
  if (len === 0) {
    return [];
  } else {
    const arr = $make_array_len_and_init(len, self[0]);
    moonbitlang$core$array$$FixedArray$unsafe_blit$5$(arr, 0, self, 0, len);
    return arr;
  }
}
function moonbitlang$core$array$$Array$copy$25$(self) {
  return moonbitlang$core$array$$JSArray$copy(self);
}
function moonbitlang$core$array$$FixedArray$makei$5$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$26$(self, that) {
  if (self.length !== that.length) {
    return false;
  }
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < self.length) {
      if (self[i] !== that[i]) {
        return false;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$immut$sorted_set$$new$27$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$4$;
}
function moonbitlang$core$immut$sorted_set$$singleton$28$(value) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$5$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$, 1, value);
}
function moonbitlang$core$immut$sorted_set$$T$size$27$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _x = _Node._2;
    return _x;
  }
}
function moonbitlang$core$immut$sorted_set$$T$size$28$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _x = _Node._2;
    return _x;
  }
}
function moonbitlang$core$immut$sorted_set$$create$27$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$4$(left, right, (moonbitlang$core$immut$sorted_set$$T$size$27$(left) + moonbitlang$core$immut$sorted_set$$T$size$27$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$create$28$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$5$(left, right, (moonbitlang$core$immut$sorted_set$$T$size$28$(left) + moonbitlang$core$immut$sorted_set$$T$size$28$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$balance$27$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$T$size$27$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$T$size$27$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$27$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$builtin$$abort$29$("balance: left is empty.");
      } else {
        const _Node = left;
        const _x = _Node._0;
        const _x$2 = _Node._3;
        const _x$3 = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$T$size$27$(_x) >= moonbitlang$core$immut$sorted_set$$T$size$27$(_x$3)) {
          return moonbitlang$core$immut$sorted_set$$create$27$(_x, _x$2, moonbitlang$core$immut$sorted_set$$create$27$(_x$3, value, right));
        } else {
          if (_x$3.$tag === 0) {
            return moonbitlang$core$builtin$$abort$29$("balance: right left.right is empty.");
          } else {
            const _Node$2 = _x$3;
            const _x$4 = _Node$2._0;
            const _x$5 = _Node$2._3;
            const _x$6 = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$27$(moonbitlang$core$immut$sorted_set$$create$27$(_x, _x$2, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$27$(_x$6, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$builtin$$abort$29$("balance: right is empty");
        } else {
          const _Node = right;
          const _x = _Node._0;
          const _x$2 = _Node._3;
          const _x$3 = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$T$size$27$(_x$3) >= moonbitlang$core$immut$sorted_set$$T$size$27$(_x)) {
            return moonbitlang$core$immut$sorted_set$$create$27$(moonbitlang$core$immut$sorted_set$$create$27$(left, value, _x), _x$2, _x$3);
          } else {
            if (_x.$tag === 0) {
              return moonbitlang$core$builtin$$abort$29$("balance: right.left is empty");
            } else {
              const _Node$2 = _x;
              const _x$4 = _Node$2._0;
              const _x$5 = _Node$2._3;
              const _x$6 = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$27$(moonbitlang$core$immut$sorted_set$$create$27$(left, value, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$27$(_x$6, _x$2, _x$3));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$27$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$balance$28$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$T$size$28$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$T$size$28$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$28$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$builtin$$abort$30$("balance: left is empty.");
      } else {
        const _Node = left;
        const _x = _Node._0;
        const _x$2 = _Node._3;
        const _x$3 = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$T$size$28$(_x) >= moonbitlang$core$immut$sorted_set$$T$size$28$(_x$3)) {
          return moonbitlang$core$immut$sorted_set$$create$28$(_x, _x$2, moonbitlang$core$immut$sorted_set$$create$28$(_x$3, value, right));
        } else {
          if (_x$3.$tag === 0) {
            return moonbitlang$core$builtin$$abort$30$("balance: right left.right is empty.");
          } else {
            const _Node$2 = _x$3;
            const _x$4 = _Node$2._0;
            const _x$5 = _Node$2._3;
            const _x$6 = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$28$(moonbitlang$core$immut$sorted_set$$create$28$(_x, _x$2, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$28$(_x$6, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$builtin$$abort$30$("balance: right is empty");
        } else {
          const _Node = right;
          const _x = _Node._0;
          const _x$2 = _Node._3;
          const _x$3 = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$T$size$28$(_x$3) >= moonbitlang$core$immut$sorted_set$$T$size$28$(_x)) {
            return moonbitlang$core$immut$sorted_set$$create$28$(moonbitlang$core$immut$sorted_set$$create$28$(left, value, _x), _x$2, _x$3);
          } else {
            if (_x.$tag === 0) {
              return moonbitlang$core$builtin$$abort$30$("balance: right.left is empty");
            } else {
              const _Node$2 = _x;
              const _x$4 = _Node$2._0;
              const _x$5 = _Node$2._3;
              const _x$6 = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$28$(moonbitlang$core$immut$sorted_set$$create$28$(left, value, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$28$(_x$6, _x$2, _x$3));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$28$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add$27$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$4$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$4$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$4$, 1, value);
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._1;
    const _x$3 = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$31$(value, _x$3);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$T$add$27$(_x, value);
        return _x === ll ? self : moonbitlang$core$immut$sorted_set$$balance$27$(ll, _x$3, _x$2);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$T$add$27$(_x$2, value);
        return _x$2 === rr ? self : moonbitlang$core$immut$sorted_set$$balance$27$(_x, _x$3, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add$28$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$5$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$, 1, value);
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._1;
    const _x$3 = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$32$(value, _x$3);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$T$add$28$(_x, value);
        return _x === ll ? self : moonbitlang$core$immut$sorted_set$$balance$28$(ll, _x$3, _x$2);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$T$add$28$(_x$2, value);
        return _x$2 === rr ? self : moonbitlang$core$immut$sorted_set$$balance$28$(_x, _x$3, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add_max_value$28$(self, value) {
  if (self.$tag === 0) {
    return moonbitlang$core$immut$sorted_set$$singleton$28$(value);
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._3;
    const _x$3 = _Node._1;
    return moonbitlang$core$immut$sorted_set$$balance$28$(_x, _x$2, moonbitlang$core$immut$sorted_set$$T$add_max_value$28$(_x$3, value));
  }
}
function moonbitlang$core$immut$sorted_set$$T$add_min_value$28$(self, value) {
  if (self.$tag === 0) {
    return moonbitlang$core$immut$sorted_set$$singleton$28$(value);
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._3;
    const _x$3 = _Node._1;
    return moonbitlang$core$immut$sorted_set$$balance$28$(moonbitlang$core$immut$sorted_set$$T$add_min_value$28$(_x, value), _x$2, _x$3);
  }
}
function moonbitlang$core$immut$sorted_set$$join$28$(left, value, right) {
  if (left.$tag === 0) {
    return moonbitlang$core$immut$sorted_set$$T$add_min_value$28$(right, value);
  } else {
    if (right.$tag === 0) {
      return moonbitlang$core$immut$sorted_set$$T$add_max_value$28$(left, value);
    } else {
      const _Node = left;
      const _x = _Node._0;
      const _x$2 = _Node._3;
      const _x$3 = _Node._1;
      const _x$4 = _Node._2;
      const _Node$2 = right;
      const _x$5 = _Node$2._0;
      const _x$6 = _Node$2._3;
      const _x$7 = _Node$2._1;
      const _x$8 = _Node$2._2;
      return _x$4 > (Math.imul(_x$8, 5) | 0) ? moonbitlang$core$immut$sorted_set$$balance$28$(_x, _x$2, moonbitlang$core$immut$sorted_set$$join$28$(_x$3, value, right)) : _x$8 > (Math.imul(_x$4, 5) | 0) ? moonbitlang$core$immut$sorted_set$$balance$28$(moonbitlang$core$immut$sorted_set$$join$28$(left, value, _x$5), _x$6, _x$7) : moonbitlang$core$immut$sorted_set$$create$28$(left, value, right);
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$split$28$(self, divide) {
  if (self.$tag === 0) {
    return { _0: $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$, _1: false, _2: $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$5$ };
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._1;
    const _x$3 = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$32$(divide, _x$3);
    if (compare_result === 0) {
      return { _0: _x, _1: true, _2: _x$2 };
    } else {
      if (compare_result < 0) {
        const _bind = moonbitlang$core$immut$sorted_set$$T$split$28$(_x, divide);
        const _x$4 = _bind._0;
        const _x$5 = _bind._1;
        const _x$6 = _bind._2;
        return { _0: _x$4, _1: _x$5, _2: moonbitlang$core$immut$sorted_set$$join$28$(_x$6, _x$3, _x$2) };
      } else {
        const _bind = moonbitlang$core$immut$sorted_set$$T$split$28$(_x$2, divide);
        const _x$4 = _bind._0;
        const _x$5 = _bind._1;
        const _x$6 = _bind._2;
        return { _0: moonbitlang$core$immut$sorted_set$$join$28$(_x, _x$3, _x$4), _1: _x$5, _2: _x$6 };
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$union$28$(self, other) {
  if (self.$tag === 0) {
    return other;
  } else {
    if (other.$tag === 0) {
      return self;
    } else {
      const _Node = self;
      const _x = _Node._0;
      const _x$2 = _Node._3;
      const _x$3 = _Node._1;
      const _x$4 = _Node._2;
      const _Node$2 = other;
      const _x$5 = _Node$2._0;
      const _x$6 = _Node$2._3;
      const _x$7 = _Node$2._1;
      const _x$8 = _Node$2._2;
      if (_x$4 >= _x$8) {
        if (_x$8 === 1) {
          return moonbitlang$core$immut$sorted_set$$T$add$28$(self, _x$6);
        } else {
          const _bind = moonbitlang$core$immut$sorted_set$$T$split$28$(other, _x$2);
          const _x$9 = _bind._0;
          const _x$10 = _bind._2;
          return moonbitlang$core$immut$sorted_set$$join$28$(moonbitlang$core$immut$sorted_set$$T$union$28$(_x, _x$9), _x$2, moonbitlang$core$immut$sorted_set$$T$union$28$(_x$3, _x$10));
        }
      } else {
        if (_x$4 === 1) {
          return moonbitlang$core$immut$sorted_set$$T$add$28$(other, _x$2);
        } else {
          const _bind = moonbitlang$core$immut$sorted_set$$T$split$28$(self, _x$6);
          const _x$9 = _bind._0;
          const _x$10 = _bind._2;
          return moonbitlang$core$immut$sorted_set$$join$28$(moonbitlang$core$immut$sorted_set$$T$union$28$(_x$9, _x$5), _x$6, moonbitlang$core$immut$sorted_set$$T$union$28$(_x$10, _x$7));
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$op_add$28$(self, other) {
  return moonbitlang$core$immut$sorted_set$$T$union$28$(self, other);
}
function moonbitlang$core$immut$sorted_set$$T$iter$27$(self) {
  return moonbitlang$core$builtin$$Iter$new$27$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Node = self;
      const _x = _Node._0;
      const _x$2 = _Node._1;
      const _x$3 = _Node._3;
      return moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter$run$27$(moonbitlang$core$immut$sorted_set$$T$iter$27$(_x), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(yield_(_x$3), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter$run$27$(moonbitlang$core$immut$sorted_set$$T$iter$27$(_x$2), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$immut$sorted_set$$T$iter$28$(self) {
  return moonbitlang$core$builtin$$Iter$new$28$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Node = self;
      const _x = _Node._0;
      const _x$2 = _Node._1;
      const _x$3 = _Node._3;
      return moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter$run$28$(moonbitlang$core$immut$sorted_set$$T$iter$28$(_x), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(yield_(_x$3), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter$run$28$(moonbitlang$core$immut$sorted_set$$T$iter$28$(_x$2), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$has(self, idx) {
  return (self & 1 << idx) !== 0;
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self, idx) {
  return $i32_popcnt(self & ((1 << idx >>> 0) - (1 >>> 0) | 0));
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$add(self, idx) {
  return self | 1 << idx;
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$size(self) {
  return $i32_popcnt(self);
}
function moonbitlang$core$immut$internal$sparse_array$$singleton$23$(idx, value) {
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(moonbitlang$core$immut$internal$sparse_array$$empty_bitset, idx), data: [value] };
}
function moonbitlang$core$immut$internal$sparse_array$$singleton$24$(idx, value) {
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(moonbitlang$core$immut$internal$sparse_array$$empty_bitset, idx), data: [value] };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$23$(self, idx) {
  return moonbitlang$core$immut$internal$sparse_array$$Bitset$has(self.elem_info, idx) ? self.data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] : undefined;
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$24$(self, idx) {
  return moonbitlang$core$immut$internal$sparse_array$$Bitset$has(self.elem_info, idx) ? self.data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] : undefined;
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$23$(self, idx, value) {
  const old_data = self.data;
  const old_len = old_data.length;
  const new_len = old_len + 1 | 0;
  const pos_of_new_item = moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx);
  const new_data = $make_array_len_and_init(new_len, value);
  moonbitlang$core$array$$FixedArray$blit_to$23$(old_data, new_data, pos_of_new_item, moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$23$(), moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$23$());
  moonbitlang$core$array$$FixedArray$blit_to$23$(old_data, new_data, old_len - pos_of_new_item | 0, pos_of_new_item, pos_of_new_item + 1 | 0);
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(self.elem_info, idx), data: new_data };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$24$(self, idx, value) {
  const old_data = self.data;
  const old_len = old_data.length;
  const new_len = old_len + 1 | 0;
  const pos_of_new_item = moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx);
  const new_data = $make_array_len_and_init(new_len, value);
  moonbitlang$core$array$$FixedArray$blit_to$24$(old_data, new_data, pos_of_new_item, moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$24$(), moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$24$());
  moonbitlang$core$array$$FixedArray$blit_to$24$(old_data, new_data, old_len - pos_of_new_item | 0, pos_of_new_item, pos_of_new_item + 1 | 0);
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(self.elem_info, idx), data: new_data };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$23$(self, idx, value) {
  const new_data = moonbitlang$core$array$$FixedArray$copy$23$(self.data);
  new_data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] = value;
  return { elem_info: self.elem_info, data: new_data };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$24$(self, idx, value) {
  const new_data = moonbitlang$core$array$$FixedArray$copy$24$(self.data);
  new_data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] = value;
  return { elem_info: self.elem_info, data: new_data };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$each$24$(self, f) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$immut$internal$sparse_array$$Bitset$size(self.elem_info)) {
      f(self.data[i]);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$size$34$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Tree = self;
    return _Tree._2;
  }
}
function moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, l, r) {
  const size = (moonbitlang$core$immut$sorted_map$$T$size$34$(l) + moonbitlang$core$immut$sorted_map$$T$size$34$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$6$(key, value, size, l, r);
}
function moonbitlang$core$immut$sorted_map$$balance$34$(key, value, l, r) {
  const ln = moonbitlang$core$immut$sorted_map$$T$size$34$(l);
  const rn = moonbitlang$core$immut$sorted_map$$T$size$34$(r);
  if ((ln + rn | 0) < 2) {
    return moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, l, r);
  } else {
    if (rn > (Math.imul(5, ln) | 0)) {
      if (r.$tag === 1) {
        const _Tree = r;
        const _x = _Tree._3;
        const _x$2 = _Tree._4;
        const rln = moonbitlang$core$immut$sorted_map$$T$size$34$(_x);
        const rrn = moonbitlang$core$immut$sorted_map$$T$size$34$(_x$2);
        if (rln < rrn) {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _x$3 = _Tree$2._0;
            const _x$4 = _Tree$2._1;
            const _x$5 = _Tree$2._3;
            const _x$6 = _Tree$2._4;
            return moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$3, _x$4, moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, l, _x$5), _x$6);
          } else {
            return $panic();
          }
        } else {
          _L: {
            if (r.$tag === 1) {
              const _Tree$2 = r;
              const _x$3 = _Tree$2._0;
              const _x$4 = _Tree$2._1;
              const _x$5 = _Tree$2._3;
              if (_x$5.$tag === 1) {
                const _Tree$3 = _x$5;
                const _x$6 = _Tree$3._0;
                const _x$7 = _Tree$3._1;
                const _x$8 = _Tree$3._3;
                const _x$9 = _Tree$3._4;
                const _x$10 = _Tree$2._4;
                return moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$6, _x$7, moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, l, _x$8), moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$3, _x$4, _x$9, _x$10));
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      if (ln > (Math.imul(5, rn) | 0)) {
        if (l.$tag === 1) {
          const _Tree = l;
          const _x = _Tree._3;
          const _x$2 = _Tree._4;
          const lln = moonbitlang$core$immut$sorted_map$$T$size$34$(_x);
          const lrn = moonbitlang$core$immut$sorted_map$$T$size$34$(_x$2);
          if (lrn < lln) {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _x$3 = _Tree$2._0;
              const _x$4 = _Tree$2._1;
              const _x$5 = _Tree$2._3;
              const _x$6 = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$3, _x$4, _x$5, moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, _x$6, r));
            } else {
              return $panic();
            }
          } else {
            _L: {
              if (l.$tag === 1) {
                const _Tree$2 = l;
                const _x$3 = _Tree$2._0;
                const _x$4 = _Tree$2._1;
                const _x$5 = _Tree$2._3;
                const _x$6 = _Tree$2._4;
                if (_x$6.$tag === 1) {
                  const _Tree$3 = _x$6;
                  const _x$7 = _Tree$3._0;
                  const _x$8 = _Tree$3._1;
                  const _x$9 = _Tree$3._3;
                  const _x$10 = _Tree$3._4;
                  return moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$7, _x$8, moonbitlang$core$immut$sorted_map$$make_tree$34$(_x$3, _x$4, _x$5, _x$9), moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, _x$10, r));
                } else {
                  break _L;
                }
              } else {
                break _L;
              }
            }
            return $panic();
          }
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$core$immut$sorted_map$$make_tree$34$(key, value, l, r);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$singleton$34$(key, value) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$6$(key, value, 1, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$6$, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$6$);
}
function moonbitlang$core$immut$sorted_map$$T$add$34$(self, key, value) {
  if (self.$tag === 0) {
    return moonbitlang$core$immut$sorted_map$$singleton$34$(key, value);
  } else {
    const _Tree = self;
    const _x = _Tree._0;
    const _x$2 = _Tree._1;
    const _x$3 = _Tree._3;
    const _x$4 = _Tree._4;
    const c = $compare_int(key, _x);
    return c === 0 ? moonbitlang$core$immut$sorted_map$$make_tree$34$(_x, value, _x$3, _x$4) : c < 0 ? moonbitlang$core$immut$sorted_map$$balance$34$(_x, _x$2, moonbitlang$core$immut$sorted_map$$T$add$34$(_x$3, key, value), _x$4) : moonbitlang$core$immut$sorted_map$$balance$34$(_x, _x$2, _x$3, moonbitlang$core$immut$sorted_map$$T$add$34$(_x$4, key, value));
  }
}
function moonbitlang$core$immut$sorted_map$$new$34$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$6$;
}
function moonbitlang$core$immut$sorted_map$$T$lookup$34$(self, key) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return undefined;
    } else {
      const _Tree = _param;
      const _x = _Tree._0;
      const _x$2 = _Tree._1;
      const _x$3 = _Tree._3;
      const _x$4 = _Tree._4;
      const c = $compare_int(key, _x);
      if (c === 0) {
        return _x$2;
      } else {
        if (c < 0) {
          _tmp = _x$3;
          continue;
        } else {
          _tmp = _x$4;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$op_get$34$(self, key) {
  return moonbitlang$core$immut$sorted_map$$T$lookup$34$(self, key);
}
function moonbitlang$core$immut$list$$T$to_array$35$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$35$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$36$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$36$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$37$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$37$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$tail$38$(self) {
  if (self.$tag === 0) {
    return $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$7$;
  } else {
    const _Cons = self;
    const _x = _Cons._1;
    return _x;
  }
}
function moonbitlang$core$immut$list$$T$unsafe_head$38$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$38$("head of empty list");
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    return _x;
  }
}
function moonbitlang$core$immut$list$$T$drop$38$(self, n) {
  let _param3;
  let _param4;
  _L: {
    if (n <= 0) {
      return self;
    } else {
      _param3 = n;
      _param4 = self;
      break _L;
    }
  }
  let _tmp = _param3;
  let _tmp$2 = _param4;
  while (true) {
    const _param3$2 = _tmp;
    const _param4$2 = _tmp$2;
    if (_param4$2.$tag === 0) {
      return $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$7$;
    } else {
      if (_param3$2 === 1) {
        const _Cons = _param4$2;
        const _x = _Cons._1;
        return _x;
      } else {
        const _Cons = _param4$2;
        const _x = _Cons._1;
        const _tmp$3 = _param3$2 - 1 | 0;
        _tmp = _tmp$3;
        _tmp$2 = _x;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$new$39$() {
  return $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$8$;
}
function moonbitlang$core$immut$hashmap$$new$40$() {
  return $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$9$;
}
function moonbitlang$core$immut$hashmap$$Bucket$find$40$(self, key) {
  let _tmp = self;
  let _tmp$2 = key;
  while (true) {
    const self$2 = _tmp;
    const key$2 = _tmp$2;
    if (self$2.$tag === 0) {
      const _Just_One = self$2;
      const _x = _Just_One._0;
      const _x$2 = _Just_One._1;
      return moonbitlang$core$builtin$$Eq$op_equal$41$(key$2, _x) ? new Option$Some$10$(_x$2) : Option$None$10$;
    } else {
      const _More = self$2;
      const _x = _More._0;
      const _x$2 = _More._1;
      const _x$3 = _More._2;
      if (moonbitlang$core$builtin$$Eq$op_equal$41$(key$2, _x)) {
        return new Option$Some$10$(_x$2);
      } else {
        _tmp = _x$3;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$find$40$(self, key) {
  let _tmp = self;
  let _tmp$2 = moonbitlang$core$builtin$$Hash$hash$42$(key);
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    switch (_param.$tag) {
      case 0: {
        return Option$None$10$;
      }
      case 1: {
        const _Leaf = _param;
        const _x = _Leaf._0;
        const _x$2 = _Leaf._1;
        return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new Option$Some$10$(_x$2) : Option$None$10$;
      }
      case 2: {
        const _Collision = _param;
        const _x$3 = _Collision._0;
        return moonbitlang$core$immut$hashmap$$Bucket$find$40$(_x$3, key);
      }
      default: {
        const _Branch = _param;
        const _x$4 = _Branch._0;
        const idx = _param$2 & 31;
        if (moonbitlang$core$immut$internal$sparse_array$$Bitset$has(_x$4.elem_info, idx)) {
          const child = _x$4.data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(_x$4.elem_info, idx)];
          const _tmp$3 = _param$2 >>> 5 | 0;
          _tmp = child;
          _tmp$2 = _tmp$3;
          continue _L;
        }
        return Option$None$10$;
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$op_get$40$(self, key) {
  return moonbitlang$core$immut$hashmap$$T$find$40$(self, key);
}
function moonbitlang$core$immut$hashmap$$Bucket$add$39$(self, key, value) {
  if (self.$tag === 0) {
    const _Just_One = self;
    const _x = _Just_One._0;
    return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$8$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$(key, value, self);
  } else {
    const _More = self;
    const _x = _More._0;
    const _x$2 = _More._1;
    const _x$3 = _More._2;
    return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$(key, value, _x$3) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$(_x, _x$2, moonbitlang$core$immut$hashmap$$Bucket$add$39$(_x$3, key, value));
  }
}
function moonbitlang$core$immut$hashmap$$Bucket$add$40$(self, key, value) {
  if (self.$tag === 0) {
    const _Just_One = self;
    const _x = _Just_One._0;
    return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$9$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$(key, value, self);
  } else {
    const _More = self;
    const _x = _More._0;
    const _x$2 = _More._1;
    const _x$3 = _More._2;
    return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$(key, value, _x$3) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$(_x, _x$2, moonbitlang$core$immut$hashmap$$Bucket$add$40$(_x$3, key, value));
  }
}
function moonbitlang$core$immut$hashmap$$T$add_with_hash$39$(self, key, depth, hash, value) {
  switch (self.$tag) {
    case 0: {
      return moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$811(depth, key, hash, value);
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$8$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$8$(new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$8$(key, value, new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$8$(_x, _x$2)));
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$8$(moonbitlang$core$immut$hashmap$$Bucket$add$39$(_x$3, key, value));
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      const idx = hash & 31;
      const _bind = moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$23$(_x$4, idx);
      if (_bind === undefined) {
        const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$811(depth + 5 | 0, key, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$8$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$23$(_x$4, idx, child));
      } else {
        const _Some = _bind;
        const _x$5 = _Some;
        const child = moonbitlang$core$immut$hashmap$$T$add_with_hash$39$(_x$5, key, depth + 5 | 0, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$8$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$23$(_x$4, idx, child));
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$811(depth, key, hash, value) {
  if (depth >= 32) {
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$8$(key, value);
  } else {
    const idx = hash & 31;
    const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$811(depth + 5 | 0, key, hash >>> 5 | 0, value);
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$8$(moonbitlang$core$immut$internal$sparse_array$$singleton$23$(idx, child));
  }
}
function moonbitlang$core$immut$hashmap$$T$add_with_hash$40$(self, key, depth, hash, value) {
  switch (self.$tag) {
    case 0: {
      return moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$836(depth, key, hash, value);
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      return moonbitlang$core$builtin$$Eq$op_equal$41$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$9$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$9$(new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$9$(key, value, new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$9$(_x, _x$2)));
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$9$(moonbitlang$core$immut$hashmap$$Bucket$add$40$(_x$3, key, value));
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      const idx = hash & 31;
      const _bind = moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$24$(_x$4, idx);
      if (_bind === undefined) {
        const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$836(depth + 5 | 0, key, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$9$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$24$(_x$4, idx, child));
      } else {
        const _Some = _bind;
        const _x$5 = _Some;
        const child = moonbitlang$core$immut$hashmap$$T$add_with_hash$40$(_x$5, key, depth + 5 | 0, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$9$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$24$(_x$4, idx, child));
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$836(depth, key, hash, value) {
  if (depth >= 32) {
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$9$(key, value);
  } else {
    const idx = hash & 31;
    const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$836(depth + 5 | 0, key, hash >>> 5 | 0, value);
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$9$(moonbitlang$core$immut$internal$sparse_array$$singleton$24$(idx, child));
  }
}
function moonbitlang$core$immut$hashmap$$T$add$39$(self, key, value) {
  return moonbitlang$core$immut$hashmap$$T$add_with_hash$39$(self, key, 0, moonbitlang$core$builtin$$Hash$hash$42$(key), value);
}
function moonbitlang$core$immut$hashmap$$T$add$40$(self, key, value) {
  return moonbitlang$core$immut$hashmap$$T$add_with_hash$40$(self, key, 0, moonbitlang$core$builtin$$Hash$hash$42$(key), value);
}
function moonbitlang$core$immut$hashmap$$Bucket$size$40$(self) {
  let _tmp = self;
  let _tmp$2 = 1;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param.$tag === 0) {
      return _param$2;
    } else {
      const _More = _param;
      const _x = _More._2;
      const _tmp$3 = _param$2 + 1 | 0;
      _tmp = _x;
      _tmp$2 = _tmp$3;
      continue;
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$size$40$(self) {
  switch (self.$tag) {
    case 0: {
      return 0;
    }
    case 1: {
      return 1;
    }
    case 2: {
      const _Collision = self;
      const _x = _Collision._0;
      return moonbitlang$core$immut$hashmap$$Bucket$size$40$(_x);
    }
    default: {
      const _Branch = self;
      const _x$2 = _Branch._0;
      let _tmp = 0;
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp;
        const total_size = _tmp$2;
        if (i < _x$2.data.length) {
          const _tmp$3 = i + 1 | 0;
          const _tmp$4 = total_size + moonbitlang$core$immut$hashmap$$T$size$40$(_x$2.data[i]) | 0;
          _tmp = _tmp$3;
          _tmp$2 = _tmp$4;
          continue;
        } else {
          return total_size;
        }
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$Bucket$each$40$(self, f) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      const _Just_One = _param;
      const _x = _Just_One._0;
      const _x$2 = _Just_One._1;
      f(_x, _x$2);
      return;
    } else {
      const _More = _param;
      const _x = _More._0;
      const _x$2 = _More._1;
      const _x$3 = _More._2;
      f(_x, _x$2);
      _tmp = _x$3;
      continue;
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$each$40$(self, f) {
  switch (self.$tag) {
    case 0: {
      return;
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      f(_x, _x$2);
      return;
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      moonbitlang$core$immut$hashmap$$Bucket$each$40$(_x$3, f);
      return;
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      moonbitlang$core$immut$internal$sparse_array$$SparseArray$each$24$(_x$4, (child) => {
        moonbitlang$core$immut$hashmap$$T$each$40$(child, f);
      });
      return;
    }
  }
}
function moonbitlang$core$immut$hashmap$$Bucket$iter$39$(self) {
  return moonbitlang$core$builtin$$Iter$new$43$((f) => {
    let _tmp = self;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        const _Just_One = _param;
        const _x = _Just_One._0;
        const _x$2 = _Just_One._1;
        return f({ _0: _x, _1: _x$2 });
      } else {
        const _More = _param;
        const _x = _More._0;
        const _x$2 = _More._1;
        const _x$3 = _More._2;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(f({ _0: _x, _1: _x$2 }), 1)) {
          _tmp = _x$3;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$immut$hashmap$$Bucket$iter$40$(self) {
  return moonbitlang$core$builtin$$Iter$new$44$((f) => {
    let _tmp = self;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        const _Just_One = _param;
        const _x = _Just_One._0;
        const _x$2 = _Just_One._1;
        return f({ _0: _x, _1: _x$2 });
      } else {
        const _More = _param;
        const _x = _More._0;
        const _x$2 = _More._1;
        const _x$3 = _More._2;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(f({ _0: _x, _1: _x$2 }), 1)) {
          _tmp = _x$3;
          continue;
        } else {
          return 0;
        }
      }
    }
  });
}
function moonbitlang$core$immut$hashmap$$T$iter$40$(self) {
  switch (self.$tag) {
    case 0: {
      return moonbitlang$core$builtin$$Iter$empty$44$();
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      return moonbitlang$core$builtin$$Iter$singleton$44$({ _0: _x, _1: _x$2 });
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      return moonbitlang$core$immut$hashmap$$Bucket$iter$40$(_x$3);
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      const _bind = _x$4.data;
      return (_p) => {
        const _len = _bind.length;
        let _tmp = 0;
        while (true) {
          const _i = _tmp;
          if (_i < _len) {
            const _p$2 = _bind[_i];
            const _func = moonbitlang$core$immut$hashmap$$T$iter$40$(_p$2);
            if (_func(_p) === 1) {
              _tmp = _i + 1 | 0;
              continue;
            } else {
              return 0;
            }
          } else {
            return 1;
          }
        }
      };
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$iter$39$(self) {
  switch (self.$tag) {
    case 0: {
      return moonbitlang$core$builtin$$Iter$empty$43$();
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      return moonbitlang$core$builtin$$Iter$singleton$43$({ _0: _x, _1: _x$2 });
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      return moonbitlang$core$immut$hashmap$$Bucket$iter$39$(_x$3);
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      const _bind = _x$4.data;
      return (_p) => {
        const _len = _bind.length;
        let _tmp = 0;
        while (true) {
          const _i = _tmp;
          if (_i < _len) {
            const _p$2 = _bind[_i];
            const _func = moonbitlang$core$immut$hashmap$$T$iter$39$(_p$2);
            if (_func(_p) === 1) {
              _tmp = _i + 1 | 0;
              continue;
            } else {
              return 0;
            }
          } else {
            return 1;
          }
        }
      };
    }
  }
}
function moonbitlang$core$immut$hashmap$$from_iter$39$(iter) {
  const _bind = moonbitlang$core$immut$hashmap$$new$39$();
  const _acc = { val: _bind };
  iter((_p) => {
    const m = _acc.val;
    _acc.val = moonbitlang$core$immut$hashmap$$T$add$39$(m, _p._0, _p._1);
    return 1;
  });
  return _acc.val;
}
function moonbitlang$core$immut$hashmap$$from_iter$40$(iter) {
  const _bind = moonbitlang$core$immut$hashmap$$new$40$();
  const _acc = { val: _bind };
  iter((_p) => {
    const m = _acc.val;
    _acc.val = moonbitlang$core$immut$hashmap$$T$add$40$(m, _p._0, _p._1);
    return 1;
  });
  return _acc.val;
}
function moonbitlang$core$builtin$$Eq$op_equal$45$(self, other) {
  if (moonbitlang$core$immut$hashmap$$T$size$40$(self) !== moonbitlang$core$immut$hashmap$$T$size$40$(other)) {
    return false;
  }
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$11$ };
  const _bind = moonbitlang$core$immut$hashmap$$T$iter$40$(self);
  _bind((kv) => {
    const _bind$2 = moonbitlang$core$immut$hashmap$$T$find$40$(other, kv._0);
    if (_bind$2.$tag === 1) {
      const _Some = _bind$2;
      const _x = _Some._0;
      if (moonbitlang$core$builtin$$op_notequal$46$(_x, kv._1)) {
        _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$11$(false);
        return 0;
      }
    } else {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$11$(false);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      return true;
    }
    case 1: {
      const _break = _tmp;
      return _break._0;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      return $panic();
    }
    default: {
      return $panic();
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$45$(self, hasher) {
  moonbitlang$core$immut$hashmap$$T$each$40$(self, (k, v) => {
    moonbitlang$core$builtin$$Hasher$combine$41$(hasher, k);
    moonbitlang$core$builtin$$Hasher$combine$46$(hasher, v);
  });
}
function moonbitlang$core$option$$Option$map$47$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    return f(_x);
  }
}
function moonbitlang$core$option$$Option$is_empty$46$(self) {
  if (self.$tag === 0) {
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$option$$Option$is_empty$5$(self) {
  return self === undefined;
}
function moonbitlang$core$option$$Option$or$48$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$or_else$24$(self, default_) {
  if (self === undefined) {
    return default_();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$builtin$$Compare$compare$49$(self, other) {
  if (self === undefined) {
    return other === undefined ? 0 : -1;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return 1;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return $compare_int(_x, _x$2);
    }
  }
}
function moonbitlang$core$sorted_map$$new_node$50$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$51$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$builtin$$Eq$op_equal$52$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$53$(self.key, other.key);
}
function moonbitlang$core$builtin$$Eq$op_equal$54$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$55$(self.key, other.key);
}
function moonbitlang$core$sorted_map$$max(x, y) {
  return x > y ? x : y;
}
function moonbitlang$core$sorted_map$$height$50$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$height$51$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$new$50$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$new$51$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$height_ge$50$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$51$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$Node$update_height$50$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$50$(self.left), moonbitlang$core$sorted_map$$height$50$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$51$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$51$(self.left), moonbitlang$core$sorted_map$$height$51$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$rotate_l$50$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$56$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$50$(n);
  moonbitlang$core$sorted_map$$Node$update_height$50$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$51$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$57$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$51$(n);
  moonbitlang$core$sorted_map$$Node$update_height$51$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_r$50$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$56$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$50$(n);
  moonbitlang$core$sorted_map$$Node$update_height$50$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$51$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$57$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$51$(n);
  moonbitlang$core$sorted_map$$Node$update_height$51$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_lr$50$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$56$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$50$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$50$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$51$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$57$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$51$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$51$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$50$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$56$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$50$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$50$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$51$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$57$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$51$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$51$(n);
}
function moonbitlang$core$sorted_map$$balance$50$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$50$(l);
  const hr = moonbitlang$core$sorted_map$$height$50$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$56$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$50$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$50$(root) : moonbitlang$core$sorted_map$$rotate_lr$50$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$56$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$50$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$50$(root) : moonbitlang$core$sorted_map$$rotate_rl$50$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$50$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$51$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$51$(l);
  const hr = moonbitlang$core$sorted_map$$height$51$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$57$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$51$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$51$(root) : moonbitlang$core$sorted_map$$rotate_lr$51$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$57$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$51$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$51$(root) : moonbitlang$core$sorted_map$$rotate_rl$51$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$51$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$add_node$50$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$50$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (moonbitlang$core$builtin$$Eq$op_equal$53$(key, _x.key)) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$58$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$50$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$50$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$50$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$50$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$51$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$51$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (moonbitlang$core$builtin$$Eq$op_equal$55$(key, _x.key)) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$21$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$51$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$51$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$51$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$51$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$add$50$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$50$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$59$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$add$51$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$51$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$60$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$op_set$50$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$50$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$op_set$51$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$51$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$get$50$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$53$(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$get$51$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$55$(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$op_get$50$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$50$(self, key);
}
function moonbitlang$core$sorted_map$$T$op_get$51$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$51$(self, key);
}
function moonbitlang$core$sorted_map$$iter_aux2$50$(node) {
  return moonbitlang$core$builtin$$Iter2$new$50$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter2$run$50$(moonbitlang$core$sorted_map$$iter_aux2$50$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter2$run$50$(moonbitlang$core$sorted_map$$iter_aux2$50$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$iter_aux2$51$(node) {
  return moonbitlang$core$builtin$$Iter2$new$51$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter2$run$51$(moonbitlang$core$sorted_map$$iter_aux2$51$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter2$run$51$(moonbitlang$core$sorted_map$$iter_aux2$51$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$T$iter2$51$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$51$(self.root);
}
function moonbitlang$core$sorted_map$$T$iter2$50$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$50$(self.root);
}
function moonbitlang$core$math$$minimum$5$(x, y) {
  return x > y ? y : x;
}
function moonbitlang$core$bool$$Bool$to_int(self) {
  return self ? 1 : 0;
}
function moonbitlang$core$queue$$new$41$() {
  return { length: 0, first: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$, last: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$ };
}
function moonbitlang$core$queue$$new$24$() {
  return { length: 0, first: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$, last: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$ };
}
function moonbitlang$core$queue$$from_array$41$(arr) {
  if (arr.length === 0) {
    return moonbitlang$core$queue$$new$41$();
  }
  const queue = moonbitlang$core$queue$$new$41$();
  queue.length = arr.length;
  queue.last = new $64$moonbitlang$47$core$47$queue$46$Cell$Cons$12$({ content: moonbitlang$core$array$$Array$op_get$41$(arr, queue.length - 1 | 0), next: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$ });
  queue.first = queue.last;
  let _tmp = arr.length - 2 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      queue.first = new $64$moonbitlang$47$core$47$queue$46$Cell$Cons$12$({ content: moonbitlang$core$array$$Array$op_get$41$(arr, i), next: queue.first });
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return queue;
}
function moonbitlang$core$queue$$T$push$24$(self, x) {
  const cell = new $64$moonbitlang$47$core$47$queue$46$Cell$Cons$13$({ content: x, next: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$ });
  const _bind = self.last;
  if (_bind.$tag === 0) {
    self.length = 1;
    self.first = cell;
    self.last = cell;
    return;
  } else {
    const _Cons = _bind;
    const _x = _Cons._0;
    _x.next = cell;
    self.length = self.length + 1 | 0;
    self.last = cell;
    return;
  }
}
function moonbitlang$core$queue$$T$push$41$(self, x) {
  const cell = new $64$moonbitlang$47$core$47$queue$46$Cell$Cons$12$({ content: x, next: $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$ });
  const _bind = self.last;
  if (_bind.$tag === 0) {
    self.length = 1;
    self.first = cell;
    self.last = cell;
    return;
  } else {
    const _Cons = _bind;
    const _x = _Cons._0;
    _x.next = cell;
    self.length = self.length + 1 | 0;
    self.last = cell;
    return;
  }
}
function moonbitlang$core$queue$$T$clear$41$(self) {
  self.length = 0;
  self.first = $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$;
  self.last = $64$moonbitlang$47$core$47$queue$46$Cell$Nil$12$;
}
function moonbitlang$core$queue$$T$clear$24$(self) {
  self.length = 0;
  self.first = $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$;
  self.last = $64$moonbitlang$47$core$47$queue$46$Cell$Nil$13$;
}
function moonbitlang$core$queue$$T$is_empty$41$(self) {
  return self.length === 0;
}
function moonbitlang$core$queue$$T$is_empty$24$(self) {
  return self.length === 0;
}
function moonbitlang$core$queue$$T$unsafe_pop$24$(self) {
  const _bind = self.first;
  if (_bind.$tag === 0) {
    return moonbitlang$core$builtin$$abort$24$("Queue is empty");
  } else {
    const _Cons = _bind;
    const _x = _Cons._0;
    const _x$2 = _x.content;
    const _x$3 = _x.next;
    if (_x$3.$tag === 0) {
      moonbitlang$core$queue$$T$clear$24$(self);
      return _x$2;
    } else {
      self.length = self.length - 1 | 0;
      self.first = _x$3;
      return _x$2;
    }
  }
}
function moonbitlang$core$queue$$T$unsafe_pop$41$(self) {
  const _bind = self.first;
  if (_bind.$tag === 0) {
    return moonbitlang$core$builtin$$abort$41$("Queue is empty");
  } else {
    const _Cons = _bind;
    const _x = _Cons._0;
    const _x$2 = _x.content;
    const _x$3 = _x.next;
    if (_x$3.$tag === 0) {
      moonbitlang$core$queue$$T$clear$41$(self);
      return _x$2;
    } else {
      self.length = self.length - 1 | 0;
      self.first = _x$3;
      return _x$2;
    }
  }
}
function moonbitlang$core$queue$$T$pop$24$(self) {
  return self.length === 0 ? undefined : moonbitlang$core$queue$$T$unsafe_pop$24$(self);
}
function moonbitlang$core$builtin$$Logger$write_object$61$(self, obj) {
  moonbitlang$core$builtin$$Show$output$62$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$63$(self, obj) {
  moonbitlang$core$builtin$$Show$output$64$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$65$(self, obj) {
  moonbitlang$core$builtin$$Show$output$66$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$67$(self, obj) {
  moonbitlang$core$builtin$$Show$output$68$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$69$(self, obj) {
  moonbitlang$core$builtin$$Show$output$69$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$11$(self, obj) {
  moonbitlang$core$builtin$$Show$output$11$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$6$(self, obj) {
  moonbitlang$core$builtin$$Show$output$6$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$5$(self, obj) {
  moonbitlang$core$builtin$$Show$output$5$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$22$(self, obj) {
  moonbitlang$core$builtin$$Show$output$70$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$71$(self, obj) {
  moonbitlang$core$builtin$$Show$output$72$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$4$(self, obj) {
  moonbitlang$core$builtin$$Show$output$4$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$73$(self, obj) {
  moonbitlang$core$builtin$$Show$output$73$(obj, self);
}
function moonbitlang$core$builtin$$Eq$op_equal$33$(_x_2487, _x_2488) {
  if (_x_2487 === 0) {
    if (_x_2488 === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    if (_x_2488 === 1) {
      return true;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$abort$29$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$30$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$19$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$41$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$24$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$74$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$75$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$76$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$38$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$77$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$8$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$10$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$11$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$5$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$78$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$73$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$79$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$6$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$4$(msg) {
  $panic();
}
function moonbitlang$core$builtin$$rotl(x, r) {
  return x << r | (x >>> (32 - r | 0) | 0);
}
function moonbitlang$core$builtin$$StringBuilder$new(size_hint) {
  return { val: "" };
}
function moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$StringBuilder$to_string(self) {
  return self.val;
}
function moonbitlang$core$builtin$$op_notequal$17$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$80$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$46$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$46$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$59$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$81$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$82$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$83$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$60$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$84$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$6$(x, y) {
  return !(x === y);
}
function moonbitlang$core$builtin$$println$85$(input) {
  console.log(moonbitlang$core$builtin$$Show$to_string$86$(input));
}
function moonbitlang$core$builtin$$println$6$(input) {
  console.log(moonbitlang$core$builtin$$Show$to_string$6$(input));
}
function moonbitlang$core$builtin$$op_lt$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$58$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$53$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$1$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$1$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$19$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$20$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$21$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$55$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$3$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$3$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_ge$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) >= 0;
}
function moonbitlang$core$builtin$$op_ge$19$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$20$(self_, other) >= 0;
}
function moonbitlang$core$builtin$$op_ge$3$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$3$(self_, other) >= 0;
}
function moonbitlang$core$builtin$$op_le$3$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$3$(self_, other) <= 0;
}
function moonbitlang$core$builtin$$Logger$write_char$12$(self, ch) {
  const _bind = self;
  _bind.val = `${_bind.val}${String.fromCodePoint(ch)}`;
}
function moonbitlang$core$array$$Array$op_get$41$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$87$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$44$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$88$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$25$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$23$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$7$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$5$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$89$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$22$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$21$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$61$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$90$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$6$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$91$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$builtin$$Logger$write_string$12$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${str}`;
}
function moonbitlang$core$bytes$$Bytes$makei(length, value) {
  if (length <= 0) {
    return new Uint8Array([]);
  }
  const arr = $make_array_len_and_init(length, value(0));
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < length) {
      arr[i] = value(i);
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$builtin$$Eq$op_equal$92$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$1$(self._0, other._0) && moonbitlang$core$builtin$$Eq$op_equal$1$(self._1, other._1);
}
function moonbitlang$core$builtin$$Eq$op_equal$93$(self, other) {
  return self._0 === other._0 && moonbitlang$core$builtin$$Eq$op_equal$53$(self._1, other._1);
}
function moonbitlang$core$builtin$$Eq$op_equal$62$(self, other) {
  return self._0 === other._0 && self._1 === other._1;
}
function moonbitlang$core$builtin$$Eq$op_equal$20$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$62$(self._0, other._0) && moonbitlang$core$builtin$$Eq$op_equal$93$(self._1, other._1);
}
function moonbitlang$core$builtin$$Eq$op_equal$32$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$41$(self._0, other._0) && (moonbitlang$core$builtin$$Eq$op_equal$46$(self._1, other._1) && moonbitlang$core$builtin$$Eq$op_equal$49$(self._2, other._2));
}
function moonbitlang$core$builtin$$Show$output$62$(self, logger) {
  const _x = self._0;
  const _x$2 = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$5$(logger, _x);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$5$(logger, _x$2);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$64$(self, logger) {
  const _x = self._0;
  const _x$2 = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$61$(logger, _x);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$61$(logger, _x$2);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$builtin$$Show$output$68$(self, logger) {
  const _x = self._0;
  const _x$2 = self._1;
  logger.method_0(logger.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$5$(logger, _x);
  logger.method_0(logger.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$65$(logger, _x$2);
  logger.method_0(logger.self, ")");
}
function moonbitlang$core$string$$String$substring(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x;
  }
  return start >= 0 && (start <= end$2 && end$2 <= len) ? self.substring(start, end$2) : $panic();
}
function moonbitlang$core$char$$Char$op_sub(self, that) {
  return self - that | 0;
}
function moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, bhi, blo) {
  const _x = self.hi;
  const _x$2 = self.lo;
  const lo = _x$2 + blo | 0;
  const s = lo >> 31;
  const as_ = _x$2 >> 31;
  const bs = blo >> 31;
  const c = (as_ & bs | ~s & (as_ ^ bs)) & 1;
  const hi = (_x + bhi | 0) + c | 0;
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$MyInt64$op_add(self, other) {
  return moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, other.hi, other.lo);
}
function moonbitlang$core$int64$$Int64$op_add(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_add(self, other);
}
function moonbitlang$core$builtin$$op_gt$6$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$6$(self_, other) > 0;
}
function moonbitlang$core$builtin$$op_gt$1$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$1$(self_, other) > 0;
}
function moonbitlang$core$builtin$$op_gt$19$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$20$(self_, other) > 0;
}
function moonbitlang$core$builtin$$op_gt$3$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$3$(self_, other) > 0;
}
function moonbitlang$core$builtin$$Logger$write_substring$12$(self, str, start, len) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$string$$String$substring(str, start, start + len | 0)}`;
}
function moonbitlang$core$builtin$$Show$output$12$(self, logger) {
  logger.method_0(logger.self, self.val);
}
function moonbitlang$core$builtin$$Hasher$combine$5$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$5$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$1$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$1$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$25$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$49$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$46$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$46$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$28$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$32$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$94$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$94$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$24$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$45$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$41$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$41$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$6$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$6$(value, self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$92$(self, hasher) {
  const _x = self._0;
  const _x$2 = self._1;
  moonbitlang$core$builtin$$Hasher$combine$1$(hasher, _x);
  moonbitlang$core$builtin$$Hasher$combine$1$(hasher, _x$2);
}
function moonbitlang$core$builtin$$Hash$hash_combine$32$(self, hasher) {
  const _x = self._0;
  const _x$2 = self._1;
  const _x$3 = self._2;
  moonbitlang$core$builtin$$Hasher$combine$41$(hasher, _x);
  moonbitlang$core$builtin$$Hasher$combine$46$(hasher, _x$2);
  moonbitlang$core$builtin$$Hasher$combine$25$(hasher, _x$3);
}
function moonbitlang$core$builtin$$power_2_above(x, n) {
  let _tmp = x;
  while (true) {
    const i = _tmp;
    if (i >= n) {
      return i;
    }
    const next = i << 1;
    if (next < 0) {
      return i;
    }
    _tmp = next;
    continue;
  }
}
function moonbitlang$core$builtin$$calc_grow_threshold(capacity) {
  return (Math.imul(capacity, 13) | 0) / 16 | 0;
}
function moonbitlang$core$builtin$$Map$new$39$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$95$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$96$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$97$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$47$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$98$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$99$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$100$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$101$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$102$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$97$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$47$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$100$() {
  return 8;
}
function moonbitlang$core$builtin$$Map$new$46$capacity$46$default$101$() {
  return 8;
}
function moonbitlang$core$array$$Array$each$25$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$43$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$103$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$104$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$105$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$106$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$37$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$97$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$101$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$39$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$47$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$100$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$96$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$95$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$98$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$99$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$102$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set$101$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$101$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$107$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$101$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && moonbitlang$core$builtin$$Eq$op_equal$45$(_x.key, _param$3.key)) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$97$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$97$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$97$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$95$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$95$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$95$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$96$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$96$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$109$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$96$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && moonbitlang$core$builtin$$Eq$op_equal$32$(_x.key, _param$3.key)) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$100$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$100$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$110$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$100$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && moonbitlang$core$builtin$$Eq$op_equal$94$(_x.key, _param$3.key)) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$47$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$47$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$47$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$39$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$39$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$42$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$39$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && moonbitlang$core$builtin$$Eq$op_equal$41$(_x.key, _param$3.key)) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$99$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$99$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$99$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$98$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$98$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$98$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$102$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$102$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$102$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$97$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$97$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$101$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$101$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$39$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$39$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$47$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$47$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$100$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$100$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$96$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$96$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$95$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$95$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$98$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$98$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$99$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$99$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$102$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$102$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$from_array$39$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$39$(arr.length);
  moonbitlang$core$array$$Array$each$43$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$39$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$96$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$96$(arr.length);
  moonbitlang$core$array$$Array$each$104$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$96$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$95$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$95$(arr.length);
  moonbitlang$core$array$$Array$each$103$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$95$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$99$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$99$(arr.length);
  moonbitlang$core$array$$Array$each$106$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$99$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$98$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$98$(arr.length);
  moonbitlang$core$array$$Array$each$105$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$98$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$102$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$102$(arr.length);
  moonbitlang$core$array$$Array$each$37$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$102$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$op_set$100$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$100$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$96$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$96$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$98$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$98$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$99$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$99$(self, key, value);
}
function moonbitlang$core$builtin$$Map$get$47$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$96$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$109$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$32$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$100$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$110$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$94$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$39$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$42$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$41$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$101$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$107$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$45$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$98$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$99$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return Option$None$14$;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return new Option$Some$14$(_x.value);
      }
      if (i > _x.psl) {
        return Option$None$14$;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$95$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$102$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$97$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$5$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$op_get$100$(self, key) {
  return moonbitlang$core$builtin$$Map$get$100$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$96$(self, key) {
  return moonbitlang$core$builtin$$Map$get$96$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$99$(self, key) {
  return moonbitlang$core$builtin$$Map$get$99$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$98$(self, key) {
  return moonbitlang$core$builtin$$Map$get$98$(self, key);
}
function moonbitlang$core$builtin$$Map$get_or_default$39$(self, key, default_) {
  const hash = moonbitlang$core$builtin$$Hash$hash$42$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return default_;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$41$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return default_;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get_or_init$101$(self, key, default_) {
  const _bind = moonbitlang$core$builtin$$Map$get$101$(self, key);
  if (_bind === undefined) {
    const v = default_();
    moonbitlang$core$builtin$$Map$set$101$(self, key, v);
    return v;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$56$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$57$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$16$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$46$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$5$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$24$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$61$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$9$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$111$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$112$(self) {
  if (self.$tag === 0) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some._0;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$67$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$builtin$$Iter$new$63$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$27$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$44$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$43$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$69$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$113$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$28$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$114$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$5$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$22$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$115$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$105$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$11$(f) {
  return f;
}
function moonbitlang$core$builtin$$Map$iter$39$(self) {
  return moonbitlang$core$builtin$$Iter$new$43$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(yield_({ _0: _x$2, _1: _x$3 }), 0)) {
          return 0;
        }
        _tmp = self.list[_x$4].next;
        continue;
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$iter$100$(self) {
  return moonbitlang$core$builtin$$Iter$new$113$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(yield_({ _0: _x$2, _1: _x$3 }), 0)) {
          return 0;
        }
        _tmp = self.list[_x$4].next;
        continue;
      }
    }
  });
}
function moonbitlang$core$builtin$$Map$iter$98$(self) {
  return moonbitlang$core$builtin$$Iter$new$105$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(yield_({ _0: _x$2, _1: _x$3 }), 0)) {
          return 0;
        }
        _tmp = self.list[_x$4].next;
        continue;
      }
    }
  });
}
function moonbitlang$core$builtin$$Iter2$new$96$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$51$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$50$(f) {
  return f;
}
function moonbitlang$core$builtin$$Map$iter2$96$(self) {
  return moonbitlang$core$builtin$$Iter2$new$96$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$33$(yield_(_x$2, _x$3), 0)) {
          return 0;
        } else {
          _tmp = self.list[_x$4].next;
          continue;
        }
      }
    }
  });
}
function moonbitlang$core$array$$Array$new$11$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$push$35$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$116$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$37$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$36$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$114$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$44$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$88$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$117$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$118$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$6$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$41$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$113$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$69$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$119$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$19$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$87$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$7$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$76$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$21$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$11$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$5$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$ArrayView$length$19$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$76$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$6$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$op_get$6$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$6$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$5$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$5$(index)}`);
}
function moonbitlang$core$array$$ArrayView$op_get$19$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$19$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$5$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$5$(index)}`);
}
function moonbitlang$core$array$$ArrayView$op_get$76$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$76$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$5$(self.len)} but the index is ${moonbitlang$core$builtin$$Show$to_string$5$(index)}`);
}
function moonbitlang$core$array$$ArrayView$swap$6$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const temp = self.buf[self.start + i | 0];
    self.buf[self.start + i | 0] = self.buf[self.start + j | 0];
    self.buf[self.start + j | 0] = temp;
    return;
  } else {
    moonbitlang$core$builtin$$abort$4$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$5$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$5$(i)}, ${moonbitlang$core$builtin$$Show$to_string$5$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$19$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const temp = self.buf[self.start + i | 0];
    self.buf[self.start + i | 0] = self.buf[self.start + j | 0];
    self.buf[self.start + j | 0] = temp;
    return;
  } else {
    moonbitlang$core$builtin$$abort$4$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$5$(self.len)} but the index is (${moonbitlang$core$builtin$$Show$to_string$5$(i)}, ${moonbitlang$core$builtin$$Show$to_string$5$(j)})`);
    return;
  }
}
function moonbitlang$core$array$$Array$op_as_view$19$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$75$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$76$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$77$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$6$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$78$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$46$start$46$default$6$() {
  return 0;
}
function moonbitlang$core$array$$Array$op_as_view$46$start$46$default$19$() {
  return 0;
}
function moonbitlang$core$array$$ArrayView$op_as_view$6$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$6$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$78$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$19$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$19$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$75$("View index out of bounds");
}
function moonbitlang$core$array$$Array$unsafe_pop$116$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$76$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$pop$116$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$116$(self);
    return v;
  }
}
function moonbitlang$core$builtin$$Hasher$new(seed) {
  return { acc: seed + 374761393 | 0 };
}
function moonbitlang$core$builtin$$Hasher$new$46$seed$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$Hasher$consume4(self, input) {
  self.acc = Math.imul(moonbitlang$core$builtin$$rotl(self.acc + (Math.imul(input, -1028477379) | 0) | 0, 17), 668265263) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_int(self, value) {
  self.acc = self.acc + 4 | 0;
  moonbitlang$core$builtin$$Hasher$consume4(self, value);
}
function moonbitlang$core$builtin$$MyInt64$to_int(self) {
  return self.lo;
}
function moonbitlang$core$int64$$Int64$to_int(self) {
  return moonbitlang$core$builtin$$MyInt64$to_int(self);
}
function moonbitlang$core$builtin$$Hasher$combine_string(self, value) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < value.length) {
      moonbitlang$core$builtin$$Hasher$combine_int(self, value.charCodeAt(i));
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Hasher$avalanche(self) {
  let acc = self.acc;
  acc = acc ^ (acc >>> 15 | 0);
  acc = Math.imul(acc, -2048144777) | 0;
  acc = acc ^ (acc >>> 13 | 0);
  acc = Math.imul(acc, -1028477379) | 0;
  acc = acc ^ (acc >>> 16 | 0);
  return acc;
}
function moonbitlang$core$builtin$$Hasher$finalize(self) {
  return moonbitlang$core$builtin$$Hasher$avalanche(self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$6$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_string(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash$5$(self) {
  const self$2 = self;
  let x = self$2 ^ (self$2 >>> 17 | 0);
  x = Math.imul(x, -312814405) | 0;
  x = x ^ (x >>> 11 | 0);
  x = Math.imul(x, -1404298415) | 0;
  x = x ^ (x >>> 15 | 0);
  x = Math.imul(x, 830770091) | 0;
  x = x ^ (x >>> 14 | 0);
  return x;
}
function moonbitlang$core$builtin$$Hash$hash_combine$5$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$49$(self, hasher) {
  if (self === undefined) {
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, 0);
    return;
  } else {
    const _Some = self;
    const _x = _Some;
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, 1);
    moonbitlang$core$builtin$$Hasher$combine$5$(hasher, _x);
    return;
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$23$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$24$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$5$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$120$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$23$(self, dst, len, src_offset, dst_offset) {
  if ((dst_offset + len | 0) > dst.length || (src_offset + len | 0) > self.length) {
    $panic();
  }
  moonbitlang$core$array$$FixedArray$unsafe_blit$23$(dst, dst_offset, self, src_offset, len);
}
function moonbitlang$core$array$$FixedArray$blit_to$24$(self, dst, len, src_offset, dst_offset) {
  if ((dst_offset + len | 0) > dst.length || (src_offset + len | 0) > self.length) {
    $panic();
  }
  moonbitlang$core$array$$FixedArray$unsafe_blit$24$(dst, dst_offset, self, src_offset, len);
}
function moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$23$() {
  return 0;
}
function moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$24$() {
  return 0;
}
function moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$23$() {
  return 0;
}
function moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$24$() {
  return 0;
}
function moonbitlang$core$builtin$$MyInt64$from_int(value) {
  return { hi: value >> 31 & -1, lo: value | 0 };
}
function moonbitlang$core$int$$Int$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_int(self);
}
function moonbitlang$core$builtin$$MyInt64$op_div(self, other) {
  const exports = moonbitlang$core$builtin$$get_int64_wasm_helper();
  const _x = self.hi;
  const _x$2 = self.lo;
  const _x$3 = other.hi;
  const _x$4 = other.lo;
  const _func = exports.div_s;
  const lo = _func(_x$2, _x, _x$4, _x$3);
  const _func$2 = exports.get_high;
  const hi = _func$2();
  return { hi: hi, lo: lo };
}
function moonbitlang$core$int64$$Int64$op_div(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_div(self, other);
}
function moonbitlang$core$builtin$$MyInt64$op_sub(self, other) {
  return other.lo === 0 ? { hi: self.hi - other.hi | 0, lo: self.lo } : moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, ~other.hi, ~other.lo + 1 | 0);
}
function moonbitlang$core$int64$$Int64$op_sub(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_sub(self, other);
}
function moonbitlang$core$builtin$$to_string$46$abs$121$(n) {
  return n < 0 ? 0 - n | 0 : n;
}
function moonbitlang$core$builtin$$to_string$46$write_digits$122$(_env, num) {
  const radix = _env._1;
  const buf = _env._0;
  const num2 = num / radix | 0;
  if (num2 !== 0) {
    moonbitlang$core$builtin$$to_string$46$write_digits$122$(_env, num2);
  }
  moonbitlang$core$builtin$$Logger$write_char$12$(buf, "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(moonbitlang$core$builtin$$to_string$46$abs$121$(num % radix | 0)));
}
function moonbitlang$core$int$$Int$to_string(self, radix) {
  const size_hint = 2 <= radix && radix < 7 ? 36 : 8 <= radix && radix < 15 ? 18 : 16 <= radix && radix <= 36 ? 10 : moonbitlang$core$builtin$$abort$5$("radix must be between 2 and 36");
  const buf = moonbitlang$core$builtin$$StringBuilder$new(size_hint);
  if (self < 0) {
    moonbitlang$core$builtin$$Logger$write_char$12$(buf, 45);
  }
  const _env = { _0: buf, _1: radix };
  moonbitlang$core$builtin$$to_string$46$write_digits$122$(_env, moonbitlang$core$builtin$$to_string$46$abs$121$(self));
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$int$$Int$to_string$46$radix$46$default() {
  return 10;
}
function moonbitlang$core$builtin$$Show$to_string$5$(self) {
  return moonbitlang$core$int$$Int$to_string(self, 10);
}
function moonbitlang$core$array$$Array$map$123$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$124$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$125$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$126$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$127$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$128$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$129$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$130$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$131$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$5$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$21$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$25$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$132$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$22$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$6$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$op_set$25$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$5$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$21$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$132$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$22$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$6$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$unsafe_blit$6$(dst, dst_offset, src, src_offset, len) {
  moonbitlang$core$array$$FixedArray$unsafe_blit$120$(dst, dst_offset, src, src_offset, len);
}
function moonbitlang$core$builtin$$Show$output$4$(_self, logger) {
  logger.method_0(logger.self, "()");
}
function moonbitlang$core$builtin$$Show$output$5$(self, logger) {
  logger.method_0(logger.self, moonbitlang$core$int$$Int$to_string(self, moonbitlang$core$int$$Int$to_string$46$radix$46$default()));
}
function moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i) {
  const logger = _env._2;
  const self = _env._1;
  const segment_start = _env._0;
  if (i > segment_start.val) {
    logger.method_1(logger.self, self, segment_start.val, i - segment_start.val | 0);
  }
  segment_start.val = i + 1 | 0;
}
function moonbitlang$core$builtin$$output$46$to_hex_digit$134$(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$builtin$$Show$output$6$(self, logger) {
  logger.method_3(logger.self, 34);
  const segment_start = { val: 0 };
  const _env = { _0: segment_start, _1: self, _2: logger };
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < self.length) {
      const c = self.charCodeAt(i);
      _L: {
        _L$2: {
          switch (c) {
            case 34: {
              break _L$2;
            }
            case 92: {
              break _L$2;
            }
            case 10: {
              moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
              logger.method_0(logger.self, "\\n");
              break;
            }
            case 13: {
              moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
              logger.method_0(logger.self, "\\r");
              break;
            }
            case 8: {
              moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
              logger.method_0(logger.self, "\\b");
              break;
            }
            case 9: {
              moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
              logger.method_0(logger.self, "\\t");
              break;
            }
            default: {
              const code = c;
              if (code < 32) {
                moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
                logger.method_3(logger.self, 92);
                logger.method_3(logger.self, 120);
                logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$134$(code / 16 | 0));
                logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$134$(code % 16 | 0));
              }
            }
          }
          break _L;
        }
        moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, i);
        logger.method_3(logger.self, 92);
        logger.method_3(logger.self, c);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$output$46$flush_segment$133$(_env, self.length);
  logger.method_3(logger.self, 34);
}
function moonbitlang$core$builtin$$Show$to_string$6$(self) {
  return self;
}
function moonbitlang$core$builtin$$Show$output$70$(self, logger) {
  if (self === undefined) {
    logger.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _x = _Some;
    logger.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$67$(logger, _x);
    logger.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Logger$write_iter$63$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$63$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$63$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$69$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$69$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$69$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$22$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$22$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$22$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$5$(self, iter, prefix, suffix, sep, trailing) {
  self.method_0(self.self, prefix);
  if (trailing) {
    iter((x) => {
      moonbitlang$core$builtin$$Logger$write_object$5$(self, x);
      self.method_0(self.self, sep);
      return 1;
    });
  } else {
    const first = { val: true };
    iter((x) => {
      if (first.val) {
        first.val = false;
      } else {
        self.method_0(self.self, sep);
      }
      moonbitlang$core$builtin$$Logger$write_object$5$(self, x);
      return 1;
    });
  }
  self.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$63$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$69$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$22$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$5$() {
  return "[";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$63$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$69$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$22$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$5$() {
  return "]";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$63$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$69$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$22$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$5$() {
  return ", ";
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$63$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$69$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$22$() {
  return false;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$5$() {
  return false;
}
function moonbitlang$core$array$$Array$iter$63$(self) {
  return moonbitlang$core$builtin$$Iter$new$63$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$69$(self) {
  return moonbitlang$core$builtin$$Iter$new$69$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$22$(self) {
  return moonbitlang$core$builtin$$Iter$new$22$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$5$(self) {
  return moonbitlang$core$builtin$$Iter$new$5$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$114$(self) {
  return moonbitlang$core$builtin$$Iter$new$114$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return 0;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$builtin$$Show$output$66$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$63$(logger, moonbitlang$core$array$$Array$iter$63$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$63$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$63$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$63$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$63$());
}
function moonbitlang$core$builtin$$Show$output$72$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$69$(logger, moonbitlang$core$array$$Array$iter$69$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$69$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$69$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$69$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$69$());
}
function moonbitlang$core$builtin$$Show$output$55$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$5$(logger, moonbitlang$core$array$$Array$iter$5$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$5$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$5$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$5$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$5$());
}
function moonbitlang$core$builtin$$Show$output$135$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$22$(logger, moonbitlang$core$array$$Array$iter$22$(self), moonbitlang$core$builtin$$Logger$write_iter$46$prefix$46$default$22$(), moonbitlang$core$builtin$$Logger$write_iter$46$suffix$46$default$22$(), moonbitlang$core$builtin$$Logger$write_iter$46$sep$46$default$22$(), moonbitlang$core$builtin$$Logger$write_iter$46$trailing$46$default$22$());
}
function moonbitlang$core$builtin$$output$46$to_hex_digit$136$(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$builtin$$Show$output$11$(self, logger) {
  logger.method_3(logger.self, 39);
  _L: {
    _L$2: {
      switch (self) {
        case 39: {
          break _L$2;
        }
        case 92: {
          break _L$2;
        }
        case 10: {
          logger.method_0(logger.self, "\\n");
          break;
        }
        case 13: {
          logger.method_0(logger.self, "\\r");
          break;
        }
        case 8: {
          logger.method_0(logger.self, "\\b");
          break;
        }
        case 9: {
          logger.method_0(logger.self, "\\t");
          break;
        }
        default: {
          const code = self;
          if (code < 32) {
            logger.method_3(logger.self, 92);
            logger.method_3(logger.self, 120);
            logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$136$(code / 16 | 0));
            logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$136$(code % 16 | 0));
          } else {
            logger.method_3(logger.self, self);
          }
        }
      }
      break _L;
    }
    logger.method_3(logger.self, 92);
    logger.method_3(logger.self, self);
  }
  logger.method_3(logger.self, 39);
}
function moonbitlang$core$builtin$$Hash$hash$110$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$94$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$109$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$28$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$42$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$41$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$107$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$24$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$108$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$6$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Logger$write_sub_string$137$(self, value, start, len) {
  moonbitlang$core$builtin$$Logger$write_substring$12$(self, value, start, len);
}
function moonbitlang$core$builtin$$Show$to_string$138$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$135$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$12$, method_1: moonbitlang$core$builtin$$Logger$write_substring$12$, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$137$, method_3: moonbitlang$core$builtin$$Logger$write_char$12$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$139$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$55$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$12$, method_1: moonbitlang$core$builtin$$Logger$write_substring$12$, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$137$, method_3: moonbitlang$core$builtin$$Logger$write_char$12$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$137$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$12$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$12$, method_1: moonbitlang$core$builtin$$Logger$write_substring$12$, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$137$, method_3: moonbitlang$core$builtin$$Logger$write_char$12$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$86$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$85$(self, { self: logger, method_0: moonbitlang$core$builtin$$Logger$write_string$12$, method_1: moonbitlang$core$builtin$$Logger$write_substring$12$, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$137$, method_3: moonbitlang$core$builtin$$Logger$write_char$12$ });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$MyInt64$op_mul(self, other) {
  const _x = self.hi;
  const _x$2 = self.lo;
  const _x$3 = other.hi;
  const _x$4 = other.lo;
  const ahi = _x;
  const alo = _x$2;
  const bhi = _x$3;
  const blo = _x$4;
  const a48 = ahi >>> 16 | 0;
  const a32 = ahi & 65535;
  const a16 = alo >>> 16 | 0;
  const a00 = alo & 65535;
  const b48 = bhi >>> 16 | 0;
  const b32 = bhi & 65535;
  const b16 = blo >>> 16 | 0;
  const b00 = blo & 65535;
  const c00 = Math.imul(a00, b00) | 0;
  const c16 = c00 >>> 16 | 0;
  const c00$2 = c00 & 65535;
  const c16$2 = (c16 >>> 0) + ((Math.imul(a16, b00) | 0) >>> 0) | 0;
  const c32 = c16$2 >>> 16 | 0;
  const c16$3 = c16$2 & 65535;
  const c16$4 = (c16$3 >>> 0) + ((Math.imul(a00, b16) | 0) >>> 0) | 0;
  const c32$2 = (c32 >>> 0) + ((c16$4 >>> 16 | 0) >>> 0) | 0;
  const c16$5 = c16$4 & 65535;
  const c32$3 = (c32$2 >>> 0) + ((Math.imul(a32, b00) | 0) >>> 0) | 0;
  const c48 = c32$3 >>> 16 | 0;
  const c32$4 = c32$3 & 65535;
  const c32$5 = (c32$4 >>> 0) + ((Math.imul(a16, b16) | 0) >>> 0) | 0;
  const c48$2 = (c48 >>> 0) + ((c32$5 >>> 16 | 0) >>> 0) | 0;
  const c32$6 = c32$5 & 65535;
  const c32$7 = (c32$6 >>> 0) + ((Math.imul(a00, b32) | 0) >>> 0) | 0;
  const c48$3 = (c48$2 >>> 0) + ((c32$7 >>> 16 | 0) >>> 0) | 0;
  const c32$8 = c32$7 & 65535;
  const c48$4 = (((((((c48$3 >>> 0) + ((Math.imul(a48, b00) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a32, b16) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a16, b32) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a00, b48) | 0) >>> 0) | 0;
  const c48$5 = c48$4 & 65535;
  return { hi: c48$5 << 16 | c32$8, lo: c16$5 << 16 | c00$2 };
}
function moonbitlang$core$int64$$Int64$op_mul(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_mul(self, other);
}
function moonbitlang$core$builtin$$Compare$compare$3$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare(self, other);
}
function moonbitlang$core$builtin$$Iter2$run$51$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter2$run$50$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Eq$op_equal$80$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$builtin$$Eq$op_equal$18$(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$83$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$builtin$$Eq$op_equal$74$(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$81$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$builtin$$Eq$op_equal$52$(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$49$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return _x === _x$2;
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$84$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$builtin$$Eq$op_equal$54$(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$140$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$op_equal$49$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$53$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$op_equal$55$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$55$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (self[i] === other[i]) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Compare$compare$140$(self, other) {
  const len_self = self.length;
  const len_other = other.length;
  const cmp = $compare_int(len_self, len_other);
  if (cmp === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len_self) {
        const cmp$2 = moonbitlang$core$builtin$$Compare$compare$49$(self[i], other[i]);
        if (cmp$2 === 0) {
        } else {
          return cmp$2;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return 0;
      }
    }
  } else {
    return cmp;
  }
}
function moonbitlang$core$builtin$$Compare$compare$53$(self, other) {
  const len_self = self.length;
  const len_other = other.length;
  const cmp = $compare_int(len_self, len_other);
  if (cmp === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len_self) {
        const cmp$2 = moonbitlang$core$builtin$$Compare$compare$55$(self[i], other[i]);
        if (cmp$2 === 0) {
        } else {
          return cmp$2;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return 0;
      }
    }
  } else {
    return cmp;
  }
}
function moonbitlang$core$builtin$$Compare$compare$55$(self, other) {
  const len_self = self.length;
  const len_other = other.length;
  const cmp = $compare_int(len_self, len_other);
  if (cmp === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len_self) {
        const cmp$2 = $compare_int(self[i], other[i]);
        if (cmp$2 === 0) {
        } else {
          return cmp$2;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return 0;
      }
    }
  } else {
    return cmp;
  }
}
function moonbitlang$core$array$$Array$map_inplace$21$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      moonbitlang$core$array$$Array$op_set$21$(self, _i, f(v));
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$mapi$141$(self, f) {
  if (self.length === 0) {
    return [];
  }
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(_i, v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$mapi_inplace$25$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      moonbitlang$core$array$$Array$op_set$25$(self, _i, f(_i, v));
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$is_empty$5$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$37$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$flatten$6$(self) {
  let len = 0;
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const x = self[_i];
      len = len + x.length | 0;
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const res = new Array(len);
  let i = 0;
  const _len$2 = self.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const xs = self[_i];
      moonbitlang$core$array$$Array$unsafe_blit$6$(res, i, xs, 0, xs.length);
      i = i + xs.length | 0;
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return res;
}
function moonbitlang$core$array$$Array$fold$47$(self, init, f) {
  let _tmp = 0;
  let _tmp$2 = init;
  while (true) {
    const i = _tmp;
    const acc = _tmp$2;
    if (i < self.length) {
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = f(acc, moonbitlang$core$array$$Array$op_get$5$(self, i));
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return acc;
    }
  }
}
function moonbitlang$core$array$$Array$fold$142$(self, init, f) {
  let _tmp = 0;
  let _tmp$2 = init;
  while (true) {
    const i = _tmp;
    const acc = _tmp$2;
    if (i < self.length) {
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = f(acc, moonbitlang$core$array$$Array$op_get$91$(self, i));
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return acc;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$93$(self, other) {
  const t0 = $compare_int(self._0, other._0);
  return t0 === 0 ? moonbitlang$core$builtin$$Compare$compare$53$(self._1, other._1) : t0;
}
function moonbitlang$core$builtin$$Compare$compare$62$(self, other) {
  const t0 = $compare_int(self._0, other._0);
  return t0 === 0 ? $compare_int(self._1, other._1) : t0;
}
function moonbitlang$core$builtin$$Compare$compare$31$(self, other) {
  const t0 = moonbitlang$core$builtin$$Compare$compare$41$(self._0, other._0);
  return t0 === 0 ? moonbitlang$core$builtin$$Compare$compare$49$(self._1, other._1) : t0;
}
function moonbitlang$core$builtin$$Compare$compare$20$(self, other) {
  const t0 = moonbitlang$core$builtin$$Compare$compare$62$(self._0, other._0);
  return t0 === 0 ? moonbitlang$core$builtin$$Compare$compare$93$(self._1, other._1) : t0;
}
function moonbitlang$core$builtin$$Compare$compare$32$(self, other) {
  const t0 = moonbitlang$core$builtin$$Compare$compare$41$(self._0, other._0);
  if (t0 === 0) {
    const t1 = moonbitlang$core$builtin$$Compare$compare$46$(self._1, other._1);
    return t1 === 0 ? moonbitlang$core$builtin$$Compare$compare$49$(self._2, other._2) : t1;
  } else {
    return t0;
  }
}
function moonbitlang$core$builtin$$Iter$run$44$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$6$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$27$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$28$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$115$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$empty$6$() {
  return (_param3) => 1;
}
function moonbitlang$core$builtin$$Iter$empty$43$() {
  return (_param3) => 1;
}
function moonbitlang$core$builtin$$Iter$empty$44$() {
  return (_param3) => 1;
}
function moonbitlang$core$builtin$$Iter$singleton$43$(a) {
  return (yield_) => yield_(a);
}
function moonbitlang$core$builtin$$Iter$singleton$44$(a) {
  return (yield_) => yield_(a);
}
function moonbitlang$core$builtin$$Iter$filter_map$143$(self, f) {
  return (yield_) => moonbitlang$core$builtin$$Iter$run$44$(self, (a) => {
    const _bind = f(a);
    if (_bind === undefined) {
      return 1;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return yield_(_x);
    }
  });
}
function moonbitlang$core$builtin$$Iter$append$6$(self, a) {
  return (yield_) => moonbitlang$core$builtin$$Eq$op_equal$33$(moonbitlang$core$builtin$$Iter$run$6$(self, yield_), 1) ? yield_(a) : 0;
}
function moonbitlang$core$builtin$$Iter$to_array$44$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$44$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$to_array$113$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$113$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$to_array$19$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$19$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$5$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$5$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$collect$6$(self) {
  const result = [];
  self((_p) => {
    moonbitlang$core$array$$Array$push$6$(result, _p);
    return 1;
  });
  return result;
}
function moonbitlang$lex$lib$util$diet$$Tree$size$1$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _x = _Node._2;
    return _x;
  }
}
function moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, l, r) {
  const size = (moonbitlang$lex$lib$util$diet$$Tree$size$1$(l) + moonbitlang$lex$lib$util$diet$$Tree$size$1$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Node$15$(l, r, size, min, max);
}
function moonbitlang$lex$lib$util$diet$$double_l$1$(min, max, l, r) {
  _L: {
    if (r.$tag === 1) {
      const _Node = r;
      const _x = _Node._0;
      if (_x.$tag === 1) {
        const _Node$2 = _x;
        return moonbitlang$lex$lib$util$diet$$make_node$1$(_Node$2._3, _Node$2._4, moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, l, _Node$2._0), moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, _Node$2._1, _Node._1));
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  return $panic();
}
function moonbitlang$lex$lib$util$diet$$double_r$1$(min, max, l, r) {
  _L: {
    if (l.$tag === 1) {
      const _Node = l;
      const _x = _Node._1;
      if (_x.$tag === 1) {
        const _Node$2 = _x;
        return moonbitlang$lex$lib$util$diet$$make_node$1$(_Node$2._3, _Node$2._4, moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, _Node._0, _Node$2._0), moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, _Node$2._1, r));
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  return $panic();
}
function moonbitlang$lex$lib$util$diet$$single_l$1$(min, max, l, r) {
  if (r.$tag === 1) {
    const _Node = r;
    return moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, l, _Node._0), _Node._1);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$util$diet$$single_r$1$(min, max, l, r) {
  if (l.$tag === 1) {
    const _Node = l;
    return moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, _Node._0, moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, _Node._1, r));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$util$diet$$balance$1$(min, max, l, r) {
  const l_size = moonbitlang$lex$lib$util$diet$$Tree$size$1$(l);
  const r_size = moonbitlang$lex$lib$util$diet$$Tree$size$1$(r);
  if ((l_size + r_size | 0) <= 1) {
    return moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, l, r);
  } else {
    if ((r_size + 1 | 0) > (Math.imul(3, l_size + 1 | 0) | 0)) {
      if (r.$tag === 1) {
        const _Node = r;
        return (moonbitlang$lex$lib$util$diet$$Tree$size$1$(_Node._0) + 1 | 0) < (Math.imul(2, moonbitlang$lex$lib$util$diet$$Tree$size$1$(_Node._1) + 1 | 0) | 0) ? moonbitlang$lex$lib$util$diet$$single_l$1$(min, max, l, _Node) : moonbitlang$lex$lib$util$diet$$double_l$1$(min, max, l, _Node);
      } else {
        return $panic();
      }
    } else {
      if ((l_size + 1 | 0) > (Math.imul(3, r_size + 1 | 0) | 0)) {
        if (l.$tag === 1) {
          const _Node = l;
          return (moonbitlang$lex$lib$util$diet$$Tree$size$1$(_Node._1) + 1 | 0) < (Math.imul(2, moonbitlang$lex$lib$util$diet$$Tree$size$1$(_Node._0) + 1 | 0) | 0) ? moonbitlang$lex$lib$util$diet$$single_r$1$(min, max, _Node, r) : moonbitlang$lex$lib$util$diet$$double_r$1$(min, max, _Node, r);
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, l, r);
      }
    }
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$slice_from$1$(self, x) {
  let _tmp = self;
  let _tmp$2 = x;
  while (true) {
    const self$2 = _tmp;
    const x$2 = _tmp$2;
    if (self$2.$tag === 0) {
      return $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$;
    } else {
      const _Node = self$2;
      if (moonbitlang$core$builtin$$op_lt$1$(x$2, _Node._3)) {
        return moonbitlang$lex$lib$util$diet$$balance$1$(_Node._3, _Node._4, moonbitlang$lex$lib$util$diet$$Tree$slice_from$1$(_Node._0, x$2), _Node._1);
      } else {
        if (moonbitlang$core$builtin$$op_gt$1$(x$2, _Node._4)) {
          _tmp = _Node._1;
          continue;
        } else {
          return moonbitlang$lex$lib$util$diet$$balance$1$(x$2, _Node._4, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$, _Node._1);
        }
      }
    }
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$slice_util$1$(self, x) {
  let _tmp = self;
  let _tmp$2 = x;
  while (true) {
    const self$2 = _tmp;
    const x$2 = _tmp$2;
    if (self$2.$tag === 0) {
      return $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$;
    } else {
      const _Node = self$2;
      if (moonbitlang$core$builtin$$op_gt$1$(x$2, _Node._4)) {
        return moonbitlang$lex$lib$util$diet$$balance$1$(_Node._3, _Node._4, _Node._0, moonbitlang$lex$lib$util$diet$$Tree$slice_util$1$(_Node._1, x$2));
      } else {
        if (moonbitlang$core$builtin$$op_lt$1$(x$2, _Node._3)) {
          _tmp = _Node._0;
          continue;
        } else {
          return moonbitlang$lex$lib$util$diet$$balance$1$(_Node._3, x$2, _Node._0, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$);
        }
      }
    }
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$slice_before$1$(self, x) {
  return moonbitlang$core$builtin$$Eq$op_equal$1$(x, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$()) ? $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ : moonbitlang$lex$lib$util$diet$$Tree$slice_util$1$(self, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$pred$1$(x));
}
function moonbitlang$lex$lib$util$diet$$Tree$slice_after$1$(self, x) {
  return moonbitlang$core$builtin$$Eq$op_equal$1$(x, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$()) ? $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ : moonbitlang$lex$lib$util$diet$$Tree$slice_from$1$(self, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$succ$1$(x));
}
function moonbitlang$lex$lib$util$diet$$Tree$slice$1$(self, min, max) {
  if (min === undefined) {
    if (max === undefined) {
      return $panic();
    } else {
      const _Some = max;
      const _x = _Some;
      return moonbitlang$lex$lib$util$diet$$Tree$slice_util$1$(self, _x);
    }
  } else {
    const _Some = min;
    const _x = _Some;
    if (max === undefined) {
      return moonbitlang$lex$lib$util$diet$$Tree$slice_from$1$(self, _x);
    } else {
      const _Some$2 = max;
      const _x$2 = _Some$2;
      return moonbitlang$lex$lib$util$diet$$Tree$slice_util$1$(moonbitlang$lex$lib$util$diet$$Tree$slice_from$1$(self, _x), _x$2);
    }
  }
}
function moonbitlang$lex$lib$util$diet$$InorderIterator$move_left$1$(self, node) {
  let _tmp = node;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return;
    } else {
      const _Node = _param;
      const _x = _Node._0;
      moonbitlang$core$array$$Array$push$116$(self, _Node);
      _tmp = _x;
      continue;
    }
  }
}
function moonbitlang$lex$lib$util$diet$$InorderIterator$new$1$(root) {
  const self = [];
  moonbitlang$lex$lib$util$diet$$InorderIterator$move_left$1$(self, root);
  return self;
}
function moonbitlang$lex$lib$util$diet$$InorderIterator$next$1$(self) {
  const _bind = moonbitlang$core$array$$Array$pop$116$(self);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 1) {
      const _Node = _x;
      const _x$2 = _Node._3;
      const _x$3 = _Node._4;
      const _x$4 = _Node._1;
      moonbitlang$lex$lib$util$diet$$InorderIterator$move_left$1$(self, _x$4);
      return { _0: _x$2, _1: _x$3 };
    } else {
      return $panic();
    }
  }
}
function moonbitlang$lex$lib$util$diet$$split_leftmost$1$(t) {
  if (t.$tag === 0) {
    return $panic();
  } else {
    const _Node = t;
    const _x = _Node._0;
    if (_x.$tag === 0) {
      const _x$2 = _Node._1;
      const _x$3 = _Node._3;
      const _x$4 = _Node._4;
      return { _0: { _0: _x$3, _1: _x$4 }, _1: _x$2 };
    } else {
      const _bind = moonbitlang$lex$lib$util$diet$$split_leftmost$1$(_Node._0);
      const _x$2 = _bind._0;
      const _x$3 = _x$2._0;
      const _x$4 = _x$2._1;
      const _x$5 = _bind._1;
      return { _0: { _0: _x$3, _1: _x$4 }, _1: moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, _x$5, _Node._1) };
    }
  }
}
function moonbitlang$lex$lib$util$diet$$split_rightmost$1$(t) {
  if (t.$tag === 0) {
    return $panic();
  } else {
    const _Node = t;
    const _x = _Node._0;
    const _x$2 = _Node._1;
    if (_x$2.$tag === 0) {
      const _x$3 = _Node._3;
      const _x$4 = _Node._4;
      return { _0: { _0: _x$3, _1: _x$4 }, _1: _x };
    } else {
      const _bind = moonbitlang$lex$lib$util$diet$$split_rightmost$1$(_Node._1);
      const _x$3 = _bind._0;
      const _x$4 = _x$3._0;
      const _x$5 = _x$3._1;
      const _x$6 = _bind._1;
      return { _0: { _0: _x$4, _1: _x$5 }, _1: moonbitlang$lex$lib$util$diet$$make_node$1$(_Node._3, _Node._4, _Node._0, _x$6) };
    }
  }
}
function moonbitlang$lex$lib$util$diet$$empty$1$() {
  return $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$;
}
function moonbitlang$lex$lib$util$diet$$singleton$1$(x) {
  return moonbitlang$lex$lib$util$diet$$make_node$1$(x, x, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$);
}
function moonbitlang$lex$lib$util$diet$$interval$1$(min, max) {
  return moonbitlang$lex$lib$util$diet$$make_node$1$(min, max, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$, $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$);
}
function moonbitlang$lex$lib$util$diet$$union$1$(t1, t2) {
  let t;
  _L: {
    if (t1.$tag === 0) {
      if (t2.$tag === 0) {
        return $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$;
      } else {
        const _Node = t2;
        t = _Node;
        break _L;
      }
    } else {
      const _Node = t1;
      if (t2.$tag === 0) {
        t = _Node;
        break _L;
      } else {
        const _Node$2 = t2;
        let t1$2;
        let t2$2;
        _L$2: {
          if (_Node._2 >= _Node$2._2) {
            t1$2 = _Node;
            t2$2 = _Node$2;
            break _L$2;
          } else {
            t1$2 = _Node$2;
            t2$2 = _Node;
            break _L$2;
          }
        }
        return moonbitlang$lex$lib$util$diet$$union_aux$1$(t1$2, t2$2);
      }
    }
  }
  return t;
}
function moonbitlang$lex$lib$util$diet$$union_aux$1$(t1, t2) {
  if (t1.$tag === 1) {
    const _Node = t1;
    if (t2.$tag === 1) {
      const _Node$2 = t2;
      const l1 = _Node._0;
      const r1 = _Node._1;
      const l2 = moonbitlang$lex$lib$util$diet$$Tree$slice_before$1$(_Node$2, _Node._3);
      const r2 = moonbitlang$lex$lib$util$diet$$Tree$slice_after$1$(_Node$2, _Node._4);
      let _bind;
      if (moonbitlang$core$builtin$$Eq$op_equal$1$(_Node._3, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$())) {
        _bind = { _0: _Node._3, _1: $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ };
      } else {
        const l = moonbitlang$lex$lib$util$diet$$union$1$(l1, l2);
        if (l.$tag === 0) {
          _bind = { _0: _Node._3, _1: $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ };
        } else {
          const _bind$2 = moonbitlang$lex$lib$util$diet$$split_rightmost$1$(l);
          const _x = _bind$2._0;
          const _x$2 = _x._0;
          const _x$3 = _x._1;
          const _x$4 = _bind$2._1;
          _bind = moonbitlang$core$builtin$$op_lt$1$(_x$3, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$()) && moonbitlang$core$builtin$$Eq$op_equal$1$(moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$succ$1$(_x$3), _Node._3) ? { _0: _x$2, _1: _x$4 } : { _0: _Node._3, _1: l };
        }
      }
      const _x = _bind._0;
      const _x$2 = _bind._1;
      let _bind$2;
      if (moonbitlang$core$builtin$$Eq$op_equal$1$(_Node._4, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$())) {
        _bind$2 = { _0: _Node._4, _1: $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ };
      } else {
        const r = moonbitlang$lex$lib$util$diet$$union$1$(r1, r2);
        if (r.$tag === 0) {
          _bind$2 = { _0: _Node._4, _1: $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ };
        } else {
          const _bind$3 = moonbitlang$lex$lib$util$diet$$split_leftmost$1$(r);
          const _x$3 = _bind$3._0;
          const _x$4 = _x$3._0;
          const _x$5 = _x$3._1;
          const _x$6 = _bind$3._1;
          _bind$2 = moonbitlang$core$builtin$$op_gt$1$(_x$4, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$()) && moonbitlang$core$builtin$$Eq$op_equal$1$(moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$pred$1$(_x$4), _Node._4) ? { _0: _x$5, _1: _x$6 } : { _0: _Node._4, _1: r };
        }
      }
      const _x$3 = _bind$2._0;
      const _x$4 = _bind$2._1;
      return moonbitlang$lex$lib$util$diet$$balance$1$(_x, _x$3, _x$2, _x$4);
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$is_empty$1$(self) {
  if (self.$tag === 0) {
    return true;
  } else {
    return false;
  }
}
function moonbitlang$lex$lib$util$diet$$concat$1$(l, r) {
  if (l.$tag === 0) {
    return r;
  } else {
    if (r.$tag === 0) {
      return l;
    } else {
      const _Node = l;
      const _Node$2 = r;
      const _bind = moonbitlang$lex$lib$util$diet$$split_leftmost$1$(_Node$2);
      const _x = _bind._0;
      const _x$2 = _x._0;
      const _x$3 = _x._1;
      const _x$4 = _bind._1;
      return moonbitlang$lex$lib$util$diet$$balance$1$(_x$2, _x$3, _Node, _x$4);
    }
  }
}
function moonbitlang$lex$lib$util$diet$$intersection$1$(t1, t2) {
  _L: {
    if (t1.$tag === 0) {
      break _L;
    } else {
      if (t2.$tag === 0) {
        break _L;
      } else {
        const _Node = t1;
        const _Node$2 = t2;
        let t1$2;
        let t2$2;
        _L$2: {
          if (_Node._2 >= _Node$2._2) {
            t1$2 = _Node;
            t2$2 = _Node$2;
            break _L$2;
          } else {
            t1$2 = _Node$2;
            t2$2 = _Node;
            break _L$2;
          }
        }
        return moonbitlang$lex$lib$util$diet$$intersection_aux$1$(t1$2, t2$2);
      }
    }
  }
  return $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$;
}
function moonbitlang$lex$lib$util$diet$$intersection_aux$1$(t1, t2) {
  if (t1.$tag === 1) {
    const _Node = t1;
    if (t2.$tag === 1) {
      const _Node$2 = t2;
      const l1 = _Node._0;
      const r1 = _Node._1;
      const l2 = moonbitlang$lex$lib$util$diet$$Tree$slice_before$1$(_Node$2, _Node._3);
      const r2 = moonbitlang$lex$lib$util$diet$$Tree$slice_after$1$(_Node$2, _Node._4);
      const l = moonbitlang$lex$lib$util$diet$$intersection$1$(l1, l2);
      const r = moonbitlang$lex$lib$util$diet$$intersection$1$(r1, r2);
      const m = moonbitlang$lex$lib$util$diet$$Tree$slice$1$(_Node$2, _Node._3, _Node._4);
      return moonbitlang$lex$lib$util$diet$$concat$1$(moonbitlang$lex$lib$util$diet$$concat$1$(l, m), r);
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$util$diet$$complement_aux$1$(min, max, t) {
  if (t.$tag === 0) {
    return moonbitlang$lex$lib$util$diet$$interval$1$(min, max);
  } else {
    const _Node = t;
    const l = moonbitlang$core$builtin$$Eq$op_equal$1$(_Node._3, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$()) ? $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ : moonbitlang$lex$lib$util$diet$$complement_aux$1$(min, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$pred$1$(_Node._3), _Node._0);
    const r = moonbitlang$core$builtin$$Eq$op_equal$1$(_Node._4, moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$()) ? $64$moonbitlang$47$lex$47$lib$47$util$47$diet$46$Tree$Empty$15$ : moonbitlang$lex$lib$util$diet$$complement_aux$1$(moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$succ$1$(_Node._4), max, _Node._1);
    return moonbitlang$lex$lib$util$diet$$concat$1$(l, r);
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$complement$1$(self) {
  return moonbitlang$lex$lib$util$diet$$complement_aux$1$(moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$(), moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$(), self);
}
function moonbitlang$lex$lib$util$diet$$difference$1$(t1, t2) {
  return moonbitlang$lex$lib$util$diet$$intersection$1$(t1, moonbitlang$lex$lib$util$diet$$Tree$complement$1$(t2));
}
function moonbitlang$core$builtin$$Eq$op_equal$144$(self, other) {
  const iter = moonbitlang$lex$lib$util$diet$$InorderIterator$new$1$(self);
  const iter1 = moonbitlang$lex$lib$util$diet$$InorderIterator$new$1$(other);
  let _tmp = moonbitlang$lex$lib$util$diet$$InorderIterator$next$1$(iter);
  let _tmp$2 = moonbitlang$lex$lib$util$diet$$InorderIterator$next$1$(iter1);
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param === undefined) {
      return _param$2 === undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      if (_param$2 === undefined) {
        return false;
      } else {
        const _Some$2 = _param$2;
        const _x$2 = _Some$2;
        if (moonbitlang$core$builtin$$Eq$op_equal$92$(_x, _x$2)) {
          const _tmp$3 = moonbitlang$lex$lib$util$diet$$InorderIterator$next$1$(iter);
          const _tmp$4 = moonbitlang$lex$lib$util$diet$$InorderIterator$next$1$(iter1);
          _tmp = _tmp$3;
          _tmp$2 = _tmp$4;
          continue;
        } else {
          return false;
        }
      }
    }
  }
}
function moonbitlang$lex$lib$util$diet$$Tree$iter_intervals$1$(self) {
  return moonbitlang$core$builtin$$Iter$new$115$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Node = self;
      const _bind = moonbitlang$core$builtin$$Iter$run$115$(moonbitlang$lex$lib$util$diet$$Tree$iter_intervals$1$(_Node._0), yield_);
      if (_bind === 1) {
        const _bind$2 = yield_({ _0: _Node._3, _1: _Node._4 });
        if (_bind$2 === 1) {
          const _bind$3 = moonbitlang$core$builtin$$Iter$run$115$(moonbitlang$lex$lib$util$diet$$Tree$iter_intervals$1$(_Node._1), yield_);
          if (_bind$3 === 1) {
            return 1;
          } else {
            return 0;
          }
        } else {
          return 0;
        }
      } else {
        return 0;
      }
    }
  });
}
function moonbitlang$core$builtin$$Hash$hash_combine$144$(self, hasher) {
  const _bind = moonbitlang$lex$lib$util$diet$$Tree$iter_intervals$1$(self);
  _bind((interval) => {
    moonbitlang$core$builtin$$Hash$hash_combine$92$(interval, hasher);
    return 1;
  });
}
function moonbitlang$core$builtin$$Eq$op_equal$1$(_x_73, _x_74) {
  return _x_73 === _x_74;
}
function moonbitlang$core$builtin$$Compare$compare$1$(_x_69, _x_70) {
  return $compare_int(_x_69, _x_70);
}
function moonbitlang$core$builtin$$Hash$hash_combine$1$(_x_65, _x_66) {
  moonbitlang$core$builtin$$Hash$hash_combine$5$(_x_65, _x_66);
}
function moonbitlang$core$builtin$$Eq$op_equal$94$(_x_55, _x_56) {
  return moonbitlang$core$builtin$$Eq$op_equal$144$(_x_55, _x_56);
}
function moonbitlang$core$builtin$$Hash$hash_combine$94$(_x_47, _x_48) {
  moonbitlang$core$builtin$$Hash$hash_combine$144$(_x_47, _x_48);
}
function moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$lower_bound$1$() {
  return -1;
}
function moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$upper_bound$1$() {
  return 1114111;
}
function moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$pred$1$(self) {
  return self > -1 ? self - 1 | 0 : $panic();
}
function moonbitlang$lex$lib$util$bounded_enum$$BoundedEnum$succ$1$(self) {
  return self < 1114111 ? self + 1 | 0 : $panic();
}
function moonbitlang$lex$lib$util$eof_char_set$$EofChar$eof() {
  return -1;
}
function moonbitlang$lex$lib$util$eof_char_set$$EofChar$char(x) {
  return x;
}
function moonbitlang$lex$lib$util$eof_char_set$$EofChar$repr(self) {
  return self === -1 ? $64$moonbitlang$47$lex$47$lib$47$util$47$eof_char_set$46$EofCharRepr$Eof : new $64$moonbitlang$47$lex$47$lib$47$util$47$eof_char_set$46$EofCharRepr$Char(self);
}
function moonbitlang$lex$lib$util$eof_char_set$$singleton(x) {
  return moonbitlang$lex$lib$util$diet$$singleton$1$(moonbitlang$lex$lib$util$eof_char_set$$EofChar$char(x));
}
function moonbitlang$lex$lib$util$eof_char_set$$range(min, max) {
  return moonbitlang$lex$lib$util$diet$$interval$1$(moonbitlang$lex$lib$util$eof_char_set$$EofChar$char(min), moonbitlang$lex$lib$util$eof_char_set$$EofChar$char(max));
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$union(self, other) {
  return moonbitlang$lex$lib$util$diet$$union$1$(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_add(self, other) {
  return moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$union(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$complement(self) {
  return moonbitlang$lex$lib$util$diet$$Tree$complement$1$(self);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$difference(self, other) {
  return moonbitlang$lex$lib$util$diet$$difference$1$(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_sub(self, other) {
  return moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$difference(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$negated(self) {
  return moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_sub(moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$complement(self), moonbitlang$lex$lib$util$eof_char_set$$eof);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$is_empty(self) {
  return moonbitlang$lex$lib$util$diet$$Tree$is_empty$1$(self);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$intersection(self, other) {
  return moonbitlang$lex$lib$util$diet$$intersection$1$(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$land(self, other) {
  return moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$intersection(self, other);
}
function moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$iter_ranges(self) {
  return moonbitlang$lex$lib$util$diet$$Tree$iter_intervals$1$(self);
}
function moonbitlang$lex$lib$type$$Regex$get_capture_names_rec(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    let re1;
    let re2;
    _L$2: {
      let re;
      _L$3: {
        switch (self$2.$tag) {
          case 9: {
            const _Capture = self$2;
            const _x = _Capture._0;
            const _x$2 = _Capture._1;
            return moonbitlang$core$builtin$$Iter$append$6$(moonbitlang$lex$lib$type$$Regex$get_capture_names_rec(_x), _x$2);
          }
          case 5: {
            const _Repetition = self$2;
            const _x$3 = _Repetition._0;
            re = _x$3;
            break _L$3;
          }
          case 6: {
            const _Option = self$2;
            const _x$4 = _Option._0;
            re = _x$4;
            break _L$3;
          }
          case 7: {
            const _Alter = self$2;
            const _x$5 = _Alter._0;
            const _x$6 = _Alter._1;
            re1 = _x$5;
            re2 = _x$6;
            break _L$2;
          }
          case 8: {
            const _Concat = self$2;
            const _x$7 = _Concat._0;
            const _x$8 = _Concat._1;
            re1 = _x$7;
            re2 = _x$8;
            break _L$2;
          }
          default: {
            return moonbitlang$core$builtin$$Iter$empty$6$();
          }
        }
      }
      _tmp = re;
      continue;
    }
    const _bind = moonbitlang$lex$lib$type$$Regex$get_capture_names_rec(re1);
    const _bind$2 = moonbitlang$lex$lib$type$$Regex$get_capture_names_rec(re2);
    return (_p) => _bind(_p) === 1 && _bind$2(_p) === 1 ? 1 : 0;
  }
}
function moonbitlang$lex$lib$type$$Regex$get_capture_names(self) {
  const result = moonbitlang$core$builtin$$Iter$collect$6$(moonbitlang$lex$lib$type$$Regex$get_capture_names_rec(self));
  moonbitlang$core$array$$Array$sort$6$(result);
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < result.length) {
      if (moonbitlang$core$array$$Array$op_get$6$(result, i - 1 | 0) === moonbitlang$core$array$$Array$op_get$6$(result, i)) {
        moonbitlang$core$builtin$$abort$4$("duplicated capture var");
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return result;
}
function moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, re) {
  let _tmp = re;
  _L: while (true) {
    const re$2 = _tmp;
    _L$2: {
      switch (re$2.$tag) {
        case 0: {
          break _L$2;
        }
        case 1: {
          break _L$2;
        }
        case 2: {
          break _L$2;
        }
        case 3: {
          break _L$2;
        }
        case 4: {
          break _L$2;
        }
        case 5: {
          const _Repetition = re$2;
          const _x = _Repetition._0;
          return new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Repetition(moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x));
        }
        case 6: {
          const _Option = re$2;
          const _x$2 = _Option._0;
          return new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Option(moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$2));
        }
        case 7: {
          const _Alter = re$2;
          const _x$3 = _Alter._0;
          const _x$4 = _Alter._1;
          return new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Alter(moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$3), moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$4));
        }
        case 8: {
          const _Concat = re$2;
          const _x$5 = _Concat._0;
          const _x$6 = _Concat._1;
          return new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Concat(moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$5), moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$6));
        }
        case 9: {
          const _Capture = re$2;
          const _x$7 = _Capture._0;
          const _x$8 = _Capture._1;
          return new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Capture(moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x$7), _x$8);
        }
        default: {
          const _Named = re$2;
          const _x$9 = _Named._0;
          const _bind = moonbitlang$core$builtin$$Map$get$102$(named_regexes, _x$9);
          if (_bind === undefined) {
            return moonbitlang$core$builtin$$abort$79$("Named regex not found");
          } else {
            const _Some = _bind;
            const _x$10 = _Some;
            _tmp = _x$10;
            continue _L;
          }
        }
      }
    }
    return re$2;
  }
}
function moonbitlang$lex$lib$type$$Lex$eliminate_named(self) {
  if (!moonbitlang$core$array$$Array$is_empty$37$(self.named_regexes)) {
    const named_regexes = moonbitlang$core$builtin$$Map$from_array$102$(self.named_regexes);
    return { header: self.header, named_regexes: [], rules: moonbitlang$core$array$$Array$map$131$(self.rules, (rule) => ({ name: rule.name, signature: rule.signature, patterns: moonbitlang$core$array$$Array$map$130$(rule.patterns, (pattern) => {
      const _x = pattern._0;
      const _x$2 = pattern._1;
      return { _0: moonbitlang$lex$lib$type$$eliminate_named$46$eliminate_named_regex$145$(named_regexes, _x), _1: _x$2 };
    }) })), trailer: self.trailer };
  } else {
    return self;
  }
}
function moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$next(self) {
  const pos = self.pos;
  const end = self.end;
  if (self.pos < end) {
    const c = self.content.charCodeAt(pos);
    if (c >= 55296 && c <= 56319) {
      const pos2 = pos + 1 | 0;
      if (pos2 < end) {
        const c2 = self.content.charCodeAt(pos2);
        if (c2 >= 56320 && c2 <= 57343) {
          self.pos = pos2 + 1 | 0;
          return (((Math.imul(c - 55296 | 0, 1024) | 0) + c2 | 0) - 56320 | 0) + 65536 | 0;
        }
      }
    }
    self.pos = pos + 1 | 0;
    return c;
  }
  return -1;
}
function moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$curr_pos(self) {
  return self.pos;
}
function moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$reset(self, pos) {
  self.pos = pos;
}
function moonbitlang$lex$45$runtime$lexbuf$$StringLexbuf$sub_lexeme(self, start, end) {
  return moonbitlang$core$string$$String$substring(self.content, start, end);
}
function moonbitlang$lex$45$runtime$lexbuf$$from_string(str, start, end) {
  return { _0: moonbitlang$lex$45$runtime$lexbuf$$string_lexbuf_class, _1: { content: str, pos: start, end: end } };
}
function moonbitlang$lex$45$runtime$lexbuf$$from_string$46$start$46$default() {
  return 0;
}
function moonbitlang$lex$45$runtime$lexbuf$$from_string$46$end$46$default(str) {
  return str.length;
}
function moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$next$146$(self) {
  const _x = self;
  const _x$2 = _x._0;
  const _x$3 = _x._1;
  const _func = _x$2.next;
  return _func(_x$3);
}
function moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$curr_pos$146$(self) {
  const _x = self;
  const _x$2 = _x._0;
  const _x$3 = _x._1;
  const _func = _x$2.curr_pos;
  return _func(_x$3);
}
function moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$reset$146$(self, pos) {
  const _x = self;
  const _x$2 = _x._0;
  const _x$3 = _x._1;
  const _func = _x$2.reset;
  _func(_x$3, pos);
}
function moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(self, start, end) {
  const _x = self;
  const _x$2 = _x._0;
  const _x$3 = _x._1;
  const _func = _x$2.sub_lexeme;
  return _func(_x$3, start, end);
}
function moonbitlang$lex$45$runtime$lexengine$$LexEngine$run$146$(self, lexbuf) {
  let state = 0;
  let tagState = [];
  const backtrace = moonbitlang$core$array$$Array$make$132$(self.code_blocks_n, undefined);
  const _arr = self.start_tags;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const tag = _arr[_i];
      while (true) {
        if (tagState.length <= tag) {
          moonbitlang$core$array$$Array$push$21$(tagState, []);
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$array$$Array$push$5$(moonbitlang$core$array$$Array$op_get$21$(tagState, tag), moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$curr_pos$146$(lexbuf));
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (state !== -1) {
      const _bind = moonbitlang$core$array$$Array$op_get$22$(self.end_nodes, state);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$array$$Array$op_set$132$(backtrace, _x._0, { _0: moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$curr_pos$146$(lexbuf), _1: state, _2: tagState });
      }
      const _bind$2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$next$146$(lexbuf);
      let b;
      if (_bind$2 === -1) {
        b = -1;
      } else {
        const _Some = _bind$2;
        const _x = _Some;
        b = _x;
      }
      const _func = moonbitlang$core$array$$Array$op_get$89$(self.graph, state);
      const next = _func(b);
      state = next._0;
      const new_tagState = [];
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i < next._1.length) {
          moonbitlang$core$array$$Array$push$21$(new_tagState, []);
          let _tmp$3 = 0;
          while (true) {
            const j = _tmp$3;
            if (j < moonbitlang$core$array$$Array$op_get$21$(next._1, i).length) {
              const t = moonbitlang$core$array$$Array$op_get$5$(moonbitlang$core$array$$Array$op_get$21$(next._1, i), j);
              if (t === -1) {
                moonbitlang$core$array$$Array$push$5$(moonbitlang$core$array$$Array$op_get$21$(new_tagState, i), moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$curr_pos$146$(lexbuf));
              } else {
                moonbitlang$core$array$$Array$push$5$(moonbitlang$core$array$$Array$op_get$21$(new_tagState, i), moonbitlang$core$array$$Array$op_get$5$(moonbitlang$core$array$$Array$op_get$21$(tagState, i), t));
              }
              _tmp$3 = j + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          _tmp$2 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      tagState = new_tagState;
      continue;
    } else {
      break;
    }
  }
  const _len$2 = backtrace.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const b = backtrace[_i];
      if (b === undefined) {
      } else {
        const _Some = b;
        const _x = _Some;
        const _x$2 = _x._0;
        const _x$3 = _x._1;
        const _x$4 = _x._2;
        moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$reset$146$(lexbuf, _x$2);
        const captures = moonbitlang$core$array$$Array$map$128$(moonbitlang$core$option$$Option$unwrap$67$(moonbitlang$core$array$$Array$op_get$22$(self.end_nodes, _x$3))._1, (_param1) => {
          const _x$5 = _param1._0;
          const _x$6 = _x$5._0;
          const _x$7 = _x$5._1;
          const _x$8 = _param1._1;
          const _x$9 = _x$8._0;
          const _x$10 = _x$8._1;
          return { _0: moonbitlang$core$array$$Array$op_get$5$(moonbitlang$core$array$$Array$op_get$21$(_x$4, _x$6), _x$7), _1: moonbitlang$core$array$$Array$op_get$5$(moonbitlang$core$array$$Array$op_get$21$(_x$4, _x$9), _x$10) };
        });
        return { _0: _i, _1: captures };
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      return { _0: self.code_blocks_n, _1: [] };
    }
  }
}
function moonbitlang$core$builtin$$Show$output$85$(_x_560, _x_561) {
  const _UnexpectedToken = _x_560;
  const _x = _UnexpectedToken._0;
  const _x$2 = _UnexpectedToken._1;
  const _x$3 = _UnexpectedToken._2;
  const _x$4 = _x$2._0;
  const _x$5 = _x$2._1;
  _x_561.method_0(_x_561.self, "UnexpectedToken(");
  moonbitlang$core$builtin$$Logger$write_object$73$(_x_561, _x);
  _x_561.method_0(_x_561.self, ", ");
  _x_561.method_0(_x_561.self, "(");
  moonbitlang$core$builtin$$Logger$write_object$4$(_x_561, _x$4);
  _x_561.method_0(_x_561.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$4$(_x_561, _x$5);
  _x_561.method_0(_x_561.self, ")");
  const self = _x_561;
  self.method_0(self.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$71$(self, _x$3);
  self.method_0(self.self, ")");
}
function moonbitlang$core$builtin$$Show$output$73$(_x_542, _x_543) {
  switch (_x_542.$tag) {
    case 0: {
      _x_543.method_0(_x_543.self, "EOI");
      return;
    }
    case 1: {
      _x_543.method_0(_x_543.self, "EOF");
      return;
    }
    case 2: {
      _x_543.method_0(_x_543.self, "PARSE_LBRACE");
      return;
    }
    case 3: {
      _x_543.method_0(_x_543.self, "LET");
      return;
    }
    case 4: {
      _x_543.method_0(_x_543.self, "AS");
      return;
    }
    case 5: {
      _x_543.method_0(_x_543.self, "UNDERSCORE");
      return;
    }
    case 6: {
      _x_543.method_0(_x_543.self, "RBRACE");
      return;
    }
    case 7: {
      _x_543.method_0(_x_543.self, "LPAREN");
      return;
    }
    case 8: {
      _x_543.method_0(_x_543.self, "RPAREN");
      return;
    }
    case 9: {
      _x_543.method_0(_x_543.self, "LBRACKET");
      return;
    }
    case 10: {
      _x_543.method_0(_x_543.self, "RBRACKET");
      return;
    }
    case 11: {
      _x_543.method_0(_x_543.self, "EQ");
      return;
    }
    case 12: {
      _x_543.method_0(_x_543.self, "SEMICOLON");
      return;
    }
    case 13: {
      _x_543.method_0(_x_543.self, "FAT_ARROW");
      return;
    }
    case 14: {
      _x_543.method_0(_x_543.self, "BAR");
      return;
    }
    case 15: {
      _x_543.method_0(_x_543.self, "STAR");
      return;
    }
    case 16: {
      _x_543.method_0(_x_543.self, "PLUS");
      return;
    }
    case 17: {
      _x_543.method_0(_x_543.self, "QUESTION");
      return;
    }
    case 18: {
      _x_543.method_0(_x_543.self, "MINUS");
      return;
    }
    case 19: {
      _x_543.method_0(_x_543.self, "CARET");
      return;
    }
    case 20: {
      const _RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE = _x_542;
      const _x = _RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE._0;
      const _x$2 = _x._0;
      const _x$3 = _x._1;
      _x_543.method_0(_x_543.self, "RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE(");
      _x_543.method_0(_x_543.self, "(");
      moonbitlang$core$builtin$$Logger$write_object$6$(_x_543, _x$2);
      _x_543.method_0(_x_543.self, ", ");
      moonbitlang$core$builtin$$Logger$write_object$6$(_x_543, _x$3);
      _x_543.method_0(_x_543.self, ")");
      _x_543.method_0(_x_543.self, ")");
      return;
    }
    case 21: {
      const _LBRACE_CODE_RBRACE = _x_542;
      const _x$4 = _LBRACE_CODE_RBRACE._0;
      _x_543.method_0(_x_543.self, "LBRACE_CODE_RBRACE(");
      moonbitlang$core$builtin$$Logger$write_object$6$(_x_543, _x$4);
      _x_543.method_0(_x_543.self, ")");
      return;
    }
    case 22: {
      const _LC_IDENT = _x_542;
      const _x$5 = _LC_IDENT._0;
      _x_543.method_0(_x_543.self, "LC_IDENT(");
      moonbitlang$core$builtin$$Logger$write_object$6$(_x_543, _x$5);
      _x_543.method_0(_x_543.self, ")");
      return;
    }
    case 23: {
      const _CHAR = _x_542;
      const _x$6 = _CHAR._0;
      _x_543.method_0(_x_543.self, "CHAR(");
      moonbitlang$core$builtin$$Logger$write_object$11$(_x_543, _x$6);
      _x_543.method_0(_x_543.self, ")");
      return;
    }
    default: {
      const _STRING = _x_542;
      const _x$7 = _STRING._0;
      _x_543.method_0(_x_543.self, "STRING(");
      moonbitlang$core$builtin$$Logger$write_object$6$(_x_543, _x$7);
      _x_543.method_0(_x_543.self, ")");
      return;
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_0(input) {
  if (input === -1) {
    return { _0: 25, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
    } else {
      switch (input) {
        case 13: {
          return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
        }
        case 32: {
          return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
        }
        case 34: {
          return { _0: 3, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 39: {
          return { _0: 4, _1: moonbitlang$lex$lib$parser$$token_tag_action_2 };
        }
        case 40: {
          return { _0: 15, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 41: {
          return { _0: 14, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 42: {
          return { _0: 9, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 43: {
          return { _0: 8, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 45: {
          return { _0: 6, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 47: {
          return { _0: 26, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 59: {
          return { _0: 11, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 61: {
          return { _0: 19, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 63: {
          return { _0: 7, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 91: {
          return { _0: 13, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 93: {
          return { _0: 12, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 94: {
          return { _0: 5, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 95: {
          return { _0: 18, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        case 97: {
          return { _0: 20, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        default: {
          if (98 <= input && input <= 100) {
            return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            if (input === 101) {
              return { _0: 24, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
            } else {
              if (102 <= input && input <= 107) {
                return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
              } else {
                if (input === 108) {
                  return { _0: 21, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                } else {
                  if (109 <= input && input <= 111) {
                    return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                  } else {
                    switch (input) {
                      case 112: {
                        return { _0: 22, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      case 113: {
                        return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      case 114: {
                        return { _0: 23, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      default: {
                        if (115 <= input && input <= 122) {
                          return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                        } else {
                          switch (input) {
                            case 123: {
                              return { _0: 17, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            case 124: {
                              return { _0: 10, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            case 125: {
                              return { _0: 16, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            default: {
                              return { _0: -1, _1: [] };
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_1(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_2(input) {
  if (input === -1) {
    return { _0: 25, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
    } else {
      switch (input) {
        case 13: {
          return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
        }
        case 32: {
          return { _0: 2, _1: moonbitlang$lex$lib$parser$$token_tag_action_1 };
        }
        case 34: {
          return { _0: 3, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 39: {
          return { _0: 4, _1: moonbitlang$lex$lib$parser$$token_tag_action_2 };
        }
        case 40: {
          return { _0: 15, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 41: {
          return { _0: 14, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 42: {
          return { _0: 9, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 43: {
          return { _0: 8, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 45: {
          return { _0: 6, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 47: {
          return { _0: 26, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 59: {
          return { _0: 11, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 61: {
          return { _0: 19, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 63: {
          return { _0: 7, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 91: {
          return { _0: 13, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 93: {
          return { _0: 12, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 94: {
          return { _0: 5, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
        }
        case 95: {
          return { _0: 18, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        case 97: {
          return { _0: 20, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        default: {
          if (98 <= input && input <= 100) {
            return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            if (input === 101) {
              return { _0: 24, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
            } else {
              if (102 <= input && input <= 107) {
                return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
              } else {
                if (input === 108) {
                  return { _0: 21, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                } else {
                  if (109 <= input && input <= 111) {
                    return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                  } else {
                    switch (input) {
                      case 112: {
                        return { _0: 22, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      case 113: {
                        return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      case 114: {
                        return { _0: 23, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                      }
                      default: {
                        if (115 <= input && input <= 122) {
                          return { _0: 1, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
                        } else {
                          switch (input) {
                            case 123: {
                              return { _0: 17, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            case 124: {
                              return { _0: 10, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            case 125: {
                              return { _0: 16, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                            }
                            default: {
                              return { _0: -1, _1: [] };
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_3(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_4(input) {
  if (0 <= input && input <= 38) {
    return { _0: 28, _1: moonbitlang$lex$lib$parser$$token_tag_action_4 };
  } else {
    if (40 <= input && input <= 91) {
      return { _0: 28, _1: moonbitlang$lex$lib$parser$$token_tag_action_4 };
    } else {
      if (input === 92) {
        return { _0: 29, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      } else {
        return 93 <= input && input <= 1114111 ? { _0: 28, _1: moonbitlang$lex$lib$parser$$token_tag_action_4 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_5(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_6(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_7(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_8(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_9(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_10(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_11(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_12(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_13(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_14(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_15(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_16(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_17(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_18(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_19(input) {
  if (input === 62) {
    return { _0: 30, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_20(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 115) {
            return { _0: 31, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_21(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 100) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 101) {
            return { _0: 32, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 102 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_22(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      switch (input) {
        case 95: {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        case 97: {
          return { _0: 33, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        }
        default: {
          return 98 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_23(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 116) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 117) {
            return { _0: 34, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 118 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_24(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 111) {
            return { _0: 35, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_25(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_26(input) {
  if (input === 47) {
    return { _0: 36, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_27(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_28(input) {
  if (input === 39) {
    return { _0: 37, _1: moonbitlang$lex$lib$parser$$token_tag_action_5 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_29(input) {
  switch (input) {
    case 39: {
      return { _0: 38, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 92: {
      return { _0: 40, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 98: {
      return { _0: 45, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 110: {
      return { _0: 41, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 114: {
      return { _0: 42, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 116: {
      return { _0: 43, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 117: {
      return { _0: 46, _1: moonbitlang$lex$lib$parser$$token_tag_action_6 };
    }
    case 118: {
      return { _0: 39, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    }
    case 120: {
      return { _0: 44, _1: moonbitlang$lex$lib$parser$$token_tag_action_7 };
    }
    default: {
      return { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_30(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_31(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_32(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 116) {
            return { _0: 47, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_33(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 113) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 114) {
            return { _0: 48, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 115 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_34(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 107) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 108) {
            return { _0: 49, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 109 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_35(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 101) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 102) {
            return { _0: 50, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 103 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_36(input) {
  if (0 <= input && input <= 9) {
    return { _0: 51, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    if (input === 10) {
      return { _0: 52, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    } else {
      return 11 <= input && input <= 1114111 ? { _0: 51, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 } : { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_37(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_38(input) {
  if (input === 39) {
    return { _0: 53, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_39(input) {
  if (input === 39) {
    return { _0: 54, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_40(input) {
  if (input === 39) {
    return { _0: 55, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_41(input) {
  if (input === 39) {
    return { _0: 56, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_42(input) {
  if (input === 39) {
    return { _0: 57, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_43(input) {
  if (input === 39) {
    return { _0: 58, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_44(input) {
  return 48 <= input && input <= 57 ? { _0: 59, _1: moonbitlang$lex$lib$parser$$token_tag_action_8 } : 65 <= input && input <= 70 ? { _0: 59, _1: moonbitlang$lex$lib$parser$$token_tag_action_8 } : 97 <= input && input <= 102 ? { _0: 59, _1: moonbitlang$lex$lib$parser$$token_tag_action_8 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_45(input) {
  if (input === 39) {
    return { _0: 60, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_46(input) {
  if (48 <= input && input <= 57) {
    return { _0: 61, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 };
  } else {
    if (65 <= input && input <= 70) {
      return { _0: 61, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 };
    } else {
      if (97 <= input && input <= 102) {
        return { _0: 61, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 };
      } else {
        if (input === 123) {
          return { _0: 62, _1: moonbitlang$lex$lib$parser$$token_tag_action_10 };
        } else {
          return { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_47(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_48(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 115) {
            return { _0: 63, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_49(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 100) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 101) {
            return { _0: 64, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 102 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_50(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_51(input) {
  if (0 <= input && input <= 9) {
    return { _0: 51, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    if (input === 10) {
      return { _0: 52, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
    } else {
      return 11 <= input && input <= 1114111 ? { _0: 51, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 } : { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_52(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_53(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_54(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_55(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_56(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_57(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_58(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_59(input) {
  return 48 <= input && input <= 57 ? { _0: 65, _1: moonbitlang$lex$lib$parser$$token_tag_action_11 } : 65 <= input && input <= 70 ? { _0: 65, _1: moonbitlang$lex$lib$parser$$token_tag_action_11 } : 97 <= input && input <= 102 ? { _0: 65, _1: moonbitlang$lex$lib$parser$$token_tag_action_11 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_60(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_61(input) {
  return 48 <= input && input <= 57 ? { _0: 66, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : 65 <= input && input <= 70 ? { _0: 66, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : 97 <= input && input <= 102 ? { _0: 66, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_62(input) {
  return 48 <= input && input <= 57 ? { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 } : 65 <= input && input <= 70 ? { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 } : 97 <= input && input <= 102 ? { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_63(input) {
  if (48 <= input && input <= 57) {
    return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
    } else {
      if (input === 95) {
        return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
      } else {
        if (97 <= input && input <= 100) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (input === 101) {
            return { _0: 68, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            return 102 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_64(input) {
  if (9 <= input && input <= 10) {
    return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
  } else {
    switch (input) {
      case 13: {
        return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
      }
      case 32: {
        return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
      }
      default: {
        if (48 <= input && input <= 57) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (65 <= input && input <= 90) {
            return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            if (input === 95) {
              return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
            } else {
              return 97 <= input && input <= 122 ? { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 } : { _0: -1, _1: [] };
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_65(input) {
  if (input === 39) {
    return { _0: 70, _1: moonbitlang$lex$lib$parser$$token_tag_action_14 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_66(input) {
  return 48 <= input && input <= 57 ? { _0: 71, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : 65 <= input && input <= 70 ? { _0: 71, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : 97 <= input && input <= 102 ? { _0: 71, _1: moonbitlang$lex$lib$parser$$token_tag_action_9 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_67(input) {
  if (48 <= input && input <= 57) {
    return { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 };
  } else {
    if (65 <= input && input <= 70) {
      return { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 };
    } else {
      if (97 <= input && input <= 102) {
        return { _0: 67, _1: moonbitlang$lex$lib$parser$$token_tag_action_12 };
      } else {
        if (input === 125) {
          return { _0: 72, _1: moonbitlang$lex$lib$parser$$token_tag_action_15 };
        } else {
          return { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_68(input) {
  if (9 <= input && input <= 10) {
    return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    switch (input) {
      case 13: {
        return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      }
      case 32: {
        return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      }
      default: {
        if (48 <= input && input <= 57) {
          return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
        } else {
          if (65 <= input && input <= 90) {
            return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
          } else {
            if (input === 95) {
              return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
            } else {
              if (97 <= input && input <= 122) {
                return { _0: 27, _1: moonbitlang$lex$lib$parser$$token_tag_action_3 };
              } else {
                if (input === 123) {
                  return { _0: 74, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
                } else {
                  return { _0: -1, _1: [] };
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_69(input) {
  if (9 <= input && input <= 10) {
    return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
  } else {
    switch (input) {
      case 13: {
        return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
      }
      case 32: {
        return { _0: 69, _1: moonbitlang$lex$lib$parser$$token_tag_action_13 };
      }
      case 95: {
        return { _0: 75, _1: moonbitlang$lex$lib$parser$$token_tag_action_16 };
      }
      default: {
        return 97 <= input && input <= 122 ? { _0: 75, _1: moonbitlang$lex$lib$parser$$token_tag_action_16 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_70(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_71(input) {
  return 48 <= input && input <= 57 ? { _0: 76, _1: moonbitlang$lex$lib$parser$$token_tag_action_17 } : 65 <= input && input <= 70 ? { _0: 76, _1: moonbitlang$lex$lib$parser$$token_tag_action_17 } : 97 <= input && input <= 102 ? { _0: 76, _1: moonbitlang$lex$lib$parser$$token_tag_action_17 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_72(input) {
  if (input === 39) {
    return { _0: 77, _1: moonbitlang$lex$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_73(input) {
  if (9 <= input && input <= 10) {
    return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
  } else {
    switch (input) {
      case 13: {
        return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      }
      case 32: {
        return { _0: 73, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      }
      case 123: {
        return { _0: 74, _1: moonbitlang$lex$lib$parser$$token_tag_action_0 };
      }
      default: {
        return { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_74(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_75(input) {
  if (0 <= input && input <= 47) {
    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
    } else {
      if (58 <= input && input <= 64) {
        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
        } else {
          if (91 <= input && input <= 94) {
            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
          } else {
            switch (input) {
              case 95: {
                return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
              }
              case 96: {
                return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
              }
              default: {
                return 97 <= input && input <= 122 ? { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 } : 124 <= input && input <= 1114111 ? { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 } : { _0: -1, _1: [] };
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_76(input) {
  if (input === 39) {
    return { _0: 80, _1: moonbitlang$lex$lib$parser$$token_tag_action_20 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$token_state_77(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_78(input) {
  if (0 <= input && input <= 8) {
    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 82, _1: moonbitlang$lex$lib$parser$$token_tag_action_21 };
    } else {
      if (11 <= input && input <= 12) {
        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
      } else {
        if (input === 13) {
          return { _0: 82, _1: moonbitlang$lex$lib$parser$$token_tag_action_21 };
        } else {
          if (14 <= input && input <= 31) {
            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
          } else {
            if (input === 32) {
              return { _0: 82, _1: moonbitlang$lex$lib$parser$$token_tag_action_21 };
            } else {
              if (33 <= input && input <= 47) {
                return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
              } else {
                if (48 <= input && input <= 57) {
                  return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
                } else {
                  if (58 <= input && input <= 64) {
                    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
                  } else {
                    if (65 <= input && input <= 90) {
                      return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
                    } else {
                      if (91 <= input && input <= 94) {
                        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
                      } else {
                        switch (input) {
                          case 95: {
                            return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
                          }
                          case 96: {
                            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
                          }
                          default: {
                            if (97 <= input && input <= 122) {
                              return { _0: 78, _1: moonbitlang$lex$lib$parser$$token_tag_action_19 };
                            } else {
                              if (input === 123) {
                                return { _0: 81, _1: moonbitlang$lex$lib$parser$$token_tag_action_22 };
                              } else {
                                return 124 <= input && input <= 1114111 ? { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 } : { _0: -1, _1: [] };
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_79(input) {
  if (0 <= input && input <= 8) {
    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
    } else {
      if (11 <= input && input <= 12) {
        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
      } else {
        if (input === 13) {
          return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
        } else {
          if (14 <= input && input <= 31) {
            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
          } else {
            if (input === 32) {
              return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
            } else {
              if (33 <= input && input <= 122) {
                return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
              } else {
                if (input === 123) {
                  return { _0: 81, _1: moonbitlang$lex$lib$parser$$token_tag_action_24 };
                } else {
                  return 124 <= input && input <= 1114111 ? { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 } : { _0: -1, _1: [] };
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_80(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_81(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$token_state_82(input) {
  if (0 <= input && input <= 8) {
    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
    } else {
      if (11 <= input && input <= 12) {
        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
      } else {
        if (input === 13) {
          return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
        } else {
          if (14 <= input && input <= 31) {
            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
          } else {
            if (input === 32) {
              return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
            } else {
              if (33 <= input && input <= 122) {
                return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
              } else {
                if (input === 123) {
                  return { _0: 81, _1: moonbitlang$lex$lib$parser$$token_tag_action_24 };
                } else {
                  return 124 <= input && input <= 1114111 ? { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 } : { _0: -1, _1: [] };
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token_state_83(input) {
  if (0 <= input && input <= 8) {
    return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
    } else {
      if (11 <= input && input <= 12) {
        return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
      } else {
        if (input === 13) {
          return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
        } else {
          if (14 <= input && input <= 31) {
            return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
          } else {
            if (input === 32) {
              return { _0: 83, _1: moonbitlang$lex$lib$parser$$token_tag_action_23 };
            } else {
              if (33 <= input && input <= 122) {
                return { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 };
              } else {
                if (input === 123) {
                  return { _0: 81, _1: moonbitlang$lex$lib$parser$$token_tag_action_24 };
                } else {
                  return 124 <= input && input <= 1114111 ? { _0: 79, _1: moonbitlang$lex$lib$parser$$token_tag_action_18 } : { _0: -1, _1: [] };
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_0(input) {
  if (input === -1) {
    return { _0: 1, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_0 };
  } else {
    if (0 <= input && input <= 33) {
      return { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
    } else {
      if (input === 34) {
        return { _0: 7, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_2 };
      } else {
        if (35 <= input && input <= 38) {
          return { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
        } else {
          if (input === 39) {
            return { _0: 5, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_3 };
          } else {
            if (40 <= input && input <= 46) {
              return { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
            } else {
              if (input === 47) {
                return { _0: 4, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_4 };
              } else {
                if (48 <= input && input <= 122) {
                  return { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
                } else {
                  switch (input) {
                    case 123: {
                      return { _0: 2, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
                    }
                    case 124: {
                      return { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
                    }
                    case 125: {
                      return { _0: 3, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 };
                    }
                    default: {
                      return 126 <= input && input <= 1114111 ? { _0: 6, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_1 } : { _0: -1, _1: [] };
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_1(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_10(input) {
  return 0 <= input && input <= 1114111 ? { _0: 15, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_11(input) {
  if (0 <= input && input <= 33) {
    return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
  } else {
    if (input === 34) {
      return { _0: 12, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_8 };
    } else {
      if (35 <= input && input <= 91) {
        return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
      } else {
        if (input === 92) {
          return { _0: 10, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
        } else {
          return 93 <= input && input <= 1114111 ? { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_12(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_13(input) {
  if (0 <= input && input <= 9) {
    return { _0: 13, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 };
  } else {
    if (input === 10) {
      return { _0: 16, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_10 };
    } else {
      return 11 <= input && input <= 1114111 ? { _0: 13, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 } : { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_14(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_15(input) {
  if (0 <= input && input <= 33) {
    return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
  } else {
    if (input === 34) {
      return { _0: 12, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_8 };
    } else {
      if (35 <= input && input <= 91) {
        return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
      } else {
        if (input === 92) {
          return { _0: 10, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
        } else {
          return 93 <= input && input <= 1114111 ? { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_16(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_2(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_3(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_4(input) {
  if (input === 47) {
    return { _0: 8, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_5(input) {
  return 0 <= input && input <= 38 ? { _0: 9, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_6 } : 40 <= input && input <= 91 ? { _0: 9, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_6 } : 93 <= input && input <= 1114111 ? { _0: 9, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_6 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_6(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_7(input) {
  if (0 <= input && input <= 33) {
    return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
  } else {
    if (input === 34) {
      return { _0: 12, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_8 };
    } else {
      if (35 <= input && input <= 91) {
        return { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
      } else {
        if (input === 92) {
          return { _0: 10, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 };
        } else {
          return 93 <= input && input <= 1114111 ? { _0: 11, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_7 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_8(input) {
  return 0 <= input && input <= 9 ? { _0: 13, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 } : 11 <= input && input <= 1114111 ? { _0: 13, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_5 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$code_rbrace_state_9(input) {
  if (input === 39) {
    return { _0: 14, _1: moonbitlang$lex$lib$parser$$code_rbrace_tag_action_9 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$code_rbrace$147$(buffer, lexbuf) {
  let _tmp = buffer;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const buffer$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$lex$45$runtime$lexengine$$LexEngine$run$146$(moonbitlang$lex$lib$parser$$__mbtlex_engine_code_rbrace, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$3, _x$4);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, t);
        continue _L;
      }
      case 1: {
        const _x$5 = _bind._1;
        const _bind$3 = moonbitlang$core$array$$Array$op_get$61$(_x$5, 0);
        const _x$6 = _bind$3._0;
        const _x$7 = _bind$3._1;
        const t$2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$6, _x$7);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, t$2);
        continue _L;
      }
      case 2: {
        const _x$8 = _bind._1;
        const _bind$4 = moonbitlang$core$array$$Array$op_get$61$(_x$8, 0);
        const _x$9 = _bind$4._0;
        const _x$10 = _bind$4._1;
        const t$3 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$9, _x$10);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, t$3);
        continue _L;
      }
      case 3: {
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, "{");
        moonbitlang$lex$lib$parser$$code_rbrace$147$(buffer$2, lexbuf$2);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, "}");
        continue _L;
      }
      case 4: {
        return;
      }
      case 5: {
        const _x$11 = _bind._1;
        const _bind$5 = moonbitlang$core$array$$Array$op_get$61$(_x$11, 0);
        const _x$12 = _bind$5._0;
        const _x$13 = _bind$5._1;
        const t$4 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$12, _x$13);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, t$4);
        continue _L;
      }
      case 6: {
        moonbitlang$core$builtin$$abort$4$("Unexpected end of input");
        return;
      }
      default: {
        moonbitlang$core$builtin$$abort$4$("lex: fail to match");
        return;
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_0(input) {
  if (input === -1) {
    return { _0: 2, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
  } else {
    if (0 <= input && input <= 33) {
      return { _0: 1, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 };
    } else {
      if (input === 34) {
        return { _0: 4, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 };
      } else {
        if (35 <= input && input <= 91) {
          return { _0: 1, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 };
        } else {
          if (input === 92) {
            return { _0: 3, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 };
          } else {
            return 93 <= input && input <= 1114111 ? { _0: 1, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_1 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_1(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_10(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_11(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_12(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_13(input) {
  if (48 <= input && input <= 57) {
    return { _0: 16, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 };
  } else {
    if (65 <= input && input <= 70) {
      return { _0: 16, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 };
    } else {
      if (97 <= input && input <= 102) {
        return { _0: 16, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 };
      } else {
        if (input === 123) {
          return { _0: 15, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_6 };
        } else {
          return { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_14(input) {
  return 48 <= input && input <= 57 ? { _0: 17, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_7 } : 65 <= input && input <= 70 ? { _0: 17, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_7 } : 97 <= input && input <= 102 ? { _0: 17, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_7 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_15(input) {
  return 48 <= input && input <= 57 ? { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 } : 65 <= input && input <= 70 ? { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 } : 97 <= input && input <= 102 ? { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_16(input) {
  return 48 <= input && input <= 57 ? { _0: 19, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : 65 <= input && input <= 70 ? { _0: 19, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : 97 <= input && input <= 102 ? { _0: 19, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_17(input) {
  if (input === 39) {
    return { _0: 20, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_9 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_18(input) {
  if (48 <= input && input <= 57) {
    return { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 };
  } else {
    if (65 <= input && input <= 70) {
      return { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 };
    } else {
      if (97 <= input && input <= 102) {
        return { _0: 18, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_8 };
      } else {
        if (input === 125) {
          return { _0: 21, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_10 };
        } else {
          return { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_19(input) {
  return 48 <= input && input <= 57 ? { _0: 22, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : 65 <= input && input <= 70 ? { _0: 22, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : 97 <= input && input <= 102 ? { _0: 22, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_5 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_2(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_20(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_21(input) {
  if (input === 39) {
    return { _0: 23, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_10 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_22(input) {
  return 48 <= input && input <= 57 ? { _0: 24, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_11 } : 65 <= input && input <= 70 ? { _0: 24, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_11 } : 97 <= input && input <= 102 ? { _0: 24, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_11 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_23(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_24(input) {
  if (input === 39) {
    return { _0: 25, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_12 };
  } else {
    return { _0: -1, _1: [] };
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_25(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_3(input) {
  switch (input) {
    case 34: {
      return { _0: 5, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 92: {
      return { _0: 11, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 98: {
      return { _0: 6, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 110: {
      return { _0: 7, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 114: {
      return { _0: 9, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 116: {
      return { _0: 10, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 117: {
      return { _0: 13, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_2 };
    }
    case 118: {
      return { _0: 12, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_0 };
    }
    case 120: {
      return { _0: 8, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_3 };
    }
    default: {
      return { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_4(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_5(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_6(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_7(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_8(input) {
  return 48 <= input && input <= 57 ? { _0: 14, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_4 } : 65 <= input && input <= 70 ? { _0: 14, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_4 } : 97 <= input && input <= 102 ? { _0: 14, _1: moonbitlang$lex$lib$parser$$string_inner_rquote_tag_action_4 } : { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote_state_9(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$parser$$string_inner_rquote$147$(buffer, lexbuf) {
  let _tmp = buffer;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const buffer$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$lex$45$runtime$lexengine$$LexEngine$run$146$(moonbitlang$lex$lib$parser$$__mbtlex_engine_string_inner_rquote, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        return;
      }
      case 1: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 8);
        continue _L;
      }
      case 2: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 9);
        continue _L;
      }
      case 3: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 11);
        continue _L;
      }
      case 4: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 13);
        continue _L;
      }
      case 5: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 10);
        continue _L;
      }
      case 6: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 92);
        continue _L;
      }
      case 7: {
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, 34);
        continue _L;
      }
      case 8: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$3, _x$4);
        const code = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t, 16));
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, code);
        return;
      }
      case 9: {
        const _x$5 = _bind._1;
        const _bind$3 = moonbitlang$core$array$$Array$op_get$61$(_x$5, 0);
        const _x$6 = _bind$3._0;
        const _x$7 = _bind$3._1;
        const t$2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$6, _x$7);
        const code$2 = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t$2, 16));
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, code$2);
        return;
      }
      case 10: {
        const _x$8 = _bind._1;
        const _bind$4 = moonbitlang$core$array$$Array$op_get$61$(_x$8, 0);
        const _x$9 = _bind$4._0;
        const _x$10 = _bind$4._1;
        const t$3 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$9, _x$10);
        const code$3 = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t$3, 16));
        moonbitlang$core$builtin$$Logger$write_char$12$(buffer$2, code$3);
        return;
      }
      case 11: {
        const _x$11 = _bind._1;
        const _bind$5 = moonbitlang$core$array$$Array$op_get$61$(_x$11, 0);
        const _x$12 = _bind$5._0;
        const _x$13 = _bind$5._1;
        const t$4 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$12, _x$13);
        moonbitlang$core$builtin$$Logger$write_string$12$(buffer$2, t$4);
        continue _L;
      }
      case 12: {
        moonbitlang$core$builtin$$abort$4$("Unexpected end of input");
        return;
      }
      default: {
        moonbitlang$core$builtin$$abort$4$("lex: fail to match");
        return;
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$token$147$(lexbuf) {
  let _tmp = lexbuf;
  _L: while (true) {
    const lexbuf$2 = _tmp;
    const _bind = moonbitlang$lex$45$runtime$lexengine$$LexEngine$run$146$(moonbitlang$lex$lib$parser$$__mbtlex_engine_token, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        continue _L;
      }
      case 1: {
        continue _L;
      }
      case 2: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EOI;
      }
      case 3: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EOF;
      }
      case 4: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t1 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$3, _x$4);
        const _bind$3 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 1);
        const _x$5 = _bind$3._0;
        const _x$6 = _bind$3._1;
        const t2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$5, _x$6);
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE({ _0: t1, _1: t2 });
      }
      case 5: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$PARSE_LBRACE;
      }
      case 6: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LET;
      }
      case 7: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$AS;
      }
      case 8: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$FAT_ARROW;
      }
      case 9: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$UNDERSCORE;
      }
      case 10: {
        const buffer = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
        moonbitlang$lex$lib$parser$$code_rbrace$147$(buffer, lexbuf$2);
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE(moonbitlang$core$builtin$$StringBuilder$to_string(buffer));
      }
      case 11: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RBRACE;
      }
      case 12: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LPAREN;
      }
      case 13: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RPAREN;
      }
      case 14: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LBRACKET;
      }
      case 15: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$RBRACKET;
      }
      case 16: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$EQ;
      }
      case 17: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$SEMICOLON;
      }
      case 18: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$BAR;
      }
      case 19: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$STAR;
      }
      case 20: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$PLUS;
      }
      case 21: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$QUESTION;
      }
      case 22: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$MINUS;
      }
      case 23: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CARET;
      }
      case 24: {
        const _x$7 = _bind._1;
        const _bind$4 = moonbitlang$core$array$$Array$op_get$61$(_x$7, 0);
        const _x$8 = _bind$4._0;
        const _x$9 = _bind$4._1;
        const t = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$8, _x$9);
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(moonbitlang$core$string$$StringView$op_get(moonbitlang$core$string$$String$op_as_view(t, moonbitlang$core$string$$String$op_as_view$46$start$46$default(), undefined), 0));
      }
      case 25: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(8);
      }
      case 26: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(9);
      }
      case 27: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(11);
      }
      case 28: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(13);
      }
      case 29: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(10);
      }
      case 30: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(92);
      }
      case 31: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(39);
      }
      case 32: {
        const _x$10 = _bind._1;
        const _bind$5 = moonbitlang$core$array$$Array$op_get$61$(_x$10, 0);
        const _x$11 = _bind$5._0;
        const _x$12 = _bind$5._1;
        const t$2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$11, _x$12);
        const code = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t$2, 16));
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(code);
      }
      case 33: {
        const _x$13 = _bind._1;
        const _bind$6 = moonbitlang$core$array$$Array$op_get$61$(_x$13, 0);
        const _x$14 = _bind$6._0;
        const _x$15 = _bind$6._1;
        const t$3 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$14, _x$15);
        const code$2 = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t$3, 16));
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(code$2);
      }
      case 34: {
        const _x$16 = _bind._1;
        const _bind$7 = moonbitlang$core$array$$Array$op_get$61$(_x$16, 0);
        const _x$17 = _bind$7._0;
        const _x$18 = _bind$7._1;
        const t$4 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$17, _x$18);
        const code$3 = moonbitlang$core$result$$Result$unwrap$13$(moonbitlang$core$strconv$$parse_int(t$4, 16));
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$CHAR(code$3);
      }
      case 35: {
        const buffer$2 = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
        moonbitlang$lex$lib$parser$$string_inner_rquote$147$(buffer$2, lexbuf$2);
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$STRING(moonbitlang$core$builtin$$StringBuilder$to_string(buffer$2));
      }
      case 36: {
        const _x$19 = _bind._1;
        const _bind$8 = moonbitlang$core$array$$Array$op_get$61$(_x$19, 0);
        const _x$20 = _bind$8._0;
        const _x$21 = _bind$8._1;
        const t$5 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$20, _x$21);
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$Token$LC_IDENT(t$5);
      }
      default: {
        return moonbitlang$core$builtin$$abort$73$("lex: fail to match");
      }
    }
  }
}
function moonbitlang$lex$lib$parser$$error(stack, token, loc) {
  const expected = [];
  const _arr = [{ _0: 0, _1: 0 }, { _0: 1, _1: 1 }, { _0: 2, _1: 2 }, { _0: 3, _1: 3 }, { _0: 4, _1: 4 }, { _0: 5, _1: 5 }, { _0: 6, _1: 6 }, { _0: 7, _1: 7 }, { _0: 8, _1: 8 }, { _0: 9, _1: 9 }, { _0: 10, _1: 10 }, { _0: 11, _1: 11 }, { _0: 12, _1: 12 }, { _0: 13, _1: 13 }, { _0: 14, _1: 14 }, { _0: 15, _1: 15 }, { _0: 16, _1: 16 }, { _0: 17, _1: 17 }, { _0: 18, _1: 18 }, { _0: 19, _1: 19 }, { _0: 20, _1: 20 }, { _0: 21, _1: 21 }, { _0: 22, _1: 22 }, { _0: 23, _1: 23 }, { _0: 24, _1: 24 }];
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = _arr[_i];
      const kind = term._1;
      const symbol = term._0;
      let stack$2;
      _L: {
        stack$2 = stack;
        break _L;
      }
      let _tmp$2 = stack$2;
      _L$2: while (true) {
        const stack$3 = _tmp$2;
        if (stack$3.$tag === 0) {
          break;
        } else {
          const _Cons = stack$3;
          const _x = _Cons._0;
          let count;
          let symbol$2;
          _L$3: {
            _L$4: {
              const _bind = _x(symbol);
              switch (_bind.$tag) {
                case 0: {
                  break _L$4;
                }
                case 1: {
                  break _L$4;
                }
                case 2: {
                  const _Reduce = _bind;
                  const _x$2 = _Reduce._0;
                  const _x$3 = _Reduce._1;
                  count = _x$2;
                  symbol$2 = _x$3;
                  break _L$3;
                }
                case 3: {
                  const _ReduceNoLookahead = _bind;
                  const _x$4 = _ReduceNoLookahead._0;
                  const _x$5 = _ReduceNoLookahead._1;
                  count = _x$4;
                  symbol$2 = _x$5;
                  break _L$3;
                }
                default: {
                  break _L$2;
                }
              }
            }
            moonbitlang$core$array$$Array$push$69$(expected, kind);
            break;
          }
          let stack$4;
          let count$2;
          let symbol$3;
          _L$4: {
            stack$4 = stack$3;
            count$2 = count;
            symbol$3 = symbol$2;
            break _L$4;
          }
          let _tmp$3 = stack$4;
          let _tmp$4 = count$2;
          let _tmp$5 = symbol$3;
          _L$5: while (true) {
            const stack$5 = _tmp$3;
            const count$3 = _tmp$4;
            const symbol$4 = _tmp$5;
            const stack$6 = moonbitlang$core$immut$list$$T$drop$38$(stack$5, count$3);
            if (stack$6.$tag === 1) {
              const _Cons$2 = stack$6;
              const _x$2 = _Cons$2._0;
              let count$4;
              let symbol$5;
              _L$6: {
                const _bind = _x$2(symbol$4);
                switch (_bind.$tag) {
                  case 1: {
                    const _Shift = _bind;
                    const _x$3 = _Shift._0;
                    _tmp$2 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$(_x$3, stack$6);
                    continue _L$2;
                  }
                  case 2: {
                    const _Reduce = _bind;
                    const _x$4 = _Reduce._0;
                    const _x$5 = _Reduce._1;
                    count$4 = _x$4;
                    symbol$5 = _x$5;
                    break _L$6;
                  }
                  case 3: {
                    const _ReduceNoLookahead = _bind;
                    const _x$6 = _ReduceNoLookahead._0;
                    const _x$7 = _ReduceNoLookahead._1;
                    count$4 = _x$6;
                    symbol$5 = _x$7;
                    break _L$6;
                  }
                  default: {
                    $panic();
                    break _L$2;
                  }
                }
              }
              _tmp$3 = stack$6;
              _tmp$4 = count$4;
              _tmp$5 = symbol$5;
              continue;
            } else {
              $panic();
              break _L$2;
            }
          }
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Err$16$(new Error$moonbitlang$47$lex$47$lib$47$parser$46$ParseError$46$UnexpectedToken(token, loc, expected));
}
function moonbitlang$lex$lib$parser$$yy_input(token, _start_pos, _end_pos) {
  switch (token.$tag) {
    case 0: {
      return { _0: 0, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 1: {
      return { _0: 1, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 2: {
      return { _0: 2, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 3: {
      return { _0: 3, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 4: {
      return { _0: 4, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 5: {
      return { _0: 5, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 6: {
      return { _0: 6, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 7: {
      return { _0: 7, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 8: {
      return { _0: 8, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 9: {
      return { _0: 9, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 10: {
      return { _0: 10, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 11: {
      return { _0: 11, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 12: {
      return { _0: 12, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 13: {
      return { _0: 13, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 14: {
      return { _0: 14, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 15: {
      return { _0: 15, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 16: {
      return { _0: 16, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 17: {
      return { _0: 17, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 18: {
      return { _0: 18, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 19: {
      return { _0: 19, _1: Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 20: {
      const _RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE = token;
      const _x = _RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE._0;
      return { _0: 20, _1: new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_(_x) };
    }
    case 21: {
      const _LBRACE_CODE_RBRACE = token;
      const _x$2 = _LBRACE_CODE_RBRACE._0;
      return { _0: 21, _1: new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$2) };
    }
    case 22: {
      const _LC_IDENT = token;
      const _x$3 = _LC_IDENT._0;
      return { _0: 22, _1: new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$3) };
    }
    case 23: {
      const _CHAR = token;
      const _x$4 = _CHAR._0;
      return { _0: 23, _1: new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_Char$46$YYObj_Char(_x$4) };
    }
    default: {
      const _STRING = token;
      const _x$5 = _STRING._0;
      return { _0: 24, _1: new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$5) };
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_parse$148$(read_token, start_pos, start, return_) {
  const state_stack = { val: new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$(start, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$7$) };
  const data_stack = [];
  const last_pos = { val: start_pos };
  const state = { val: start };
  let lookahead = undefined;
  let last_shifted_state_stack = state_stack.val;
  while (true) {
    let decision;
    const _func = state.val;
    const _bind = _func(45);
    switch (_bind.$tag) {
      case 3: {
        decision = _bind;
        break;
      }
      case 0: {
        decision = _bind;
        break;
      }
      default: {
        const _bind$2 = lookahead;
        if (_bind$2 === undefined) {
          const _bind$3 = read_token();
          const _x = _bind$3._0;
          const _x$2 = _bind$3._1;
          const _x$3 = _bind$3._2;
          const _bind$4 = moonbitlang$lex$lib$parser$$yy_input(_x, _x$2, _x$3);
          const _x$4 = _bind$4._0;
          const _x$5 = _bind$4._1;
          lookahead = { _0: _x$4, _1: { _0: _x$5, _1: _x$2, _2: _x$3 }, _2: _x };
          const _func$2 = state.val;
          decision = _func$2(_x$4);
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _func$2 = state.val;
          decision = _func$2(_x._0);
        }
      }
    }
    let action;
    let count;
    let symbol;
    _L: {
      _L$2: {
        switch (decision.$tag) {
          case 0: {
            return new Result$Ok$17$(return_(moonbitlang$core$array$$Array$unsafe_pop$76$(data_stack)._0));
          }
          case 1: {
            const _Shift = decision;
            const _x = _Shift._0;
            const _bind$3 = lookahead;
            if (_bind$3 === undefined) {
              $panic();
            } else {
              const _Some = _bind$3;
              const _x$2 = _Some;
              moonbitlang$core$array$$Array$push$76$(data_stack, _x$2._1);
              state_stack.val = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$(_x, state_stack.val);
              last_shifted_state_stack = state_stack.val;
              state.val = _x;
              last_pos.val = _x$2._1._2;
              lookahead = undefined;
            }
            break;
          }
          case 2: {
            const _Reduce = decision;
            const _x$2 = _Reduce._0;
            const _x$3 = _Reduce._1;
            const _x$4 = _Reduce._2;
            action = _x$4;
            count = _x$2;
            symbol = _x$3;
            break _L$2;
          }
          case 3: {
            const _ReduceNoLookahead = decision;
            const _x$5 = _ReduceNoLookahead._0;
            const _x$6 = _ReduceNoLookahead._1;
            const _x$7 = _ReduceNoLookahead._2;
            action = _x$7;
            count = _x$5;
            symbol = _x$6;
            break _L$2;
          }
          default: {
            const _bind$4 = moonbitlang$core$option$$Option$unwrap$111$(lookahead);
            const _x$8 = _bind$4._1;
            const _x$9 = _x$8._1;
            const _x$10 = _x$8._2;
            const _x$11 = _bind$4._2;
            const _bind$5 = moonbitlang$lex$lib$parser$$error(last_shifted_state_stack, _x$11, { _0: _x$9, _1: _x$10 });
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              _ok._0;
            } else {
              return _bind$5;
            }
          }
        }
        break _L;
      }
      let _tmp = count;
      let _tmp$2 = symbol;
      let _tmp$3 = action;
      _L$3: while (true) {
        const args = moonbitlang$core$array$$Array$op_as_view$76$(data_stack, data_stack.length - count | 0, undefined);
        const data = action(last_pos.val, args);
        let start_pos$2;
        let end_pos;
        _L$4: {
          if (moonbitlang$core$array$$ArrayView$length$76$(args) === 0) {
            const _tmp$4 = last_pos.val;
            const _tmp$5 = last_pos.val;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          } else {
            const _tmp$4 = moonbitlang$core$array$$ArrayView$op_get$76$(args, 0)._1;
            const _tmp$5 = moonbitlang$core$array$$ArrayView$op_get$76$(args, moonbitlang$core$array$$ArrayView$length$76$(args) - 1 | 0)._2;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          }
        }
        let _tmp$4 = 0;
        while (true) {
          const i = _tmp$4;
          if (i < count) {
            moonbitlang$core$array$$Array$unsafe_pop$76$(data_stack);
            state_stack.val = moonbitlang$core$immut$list$$T$tail$38$(state_stack.val);
            _tmp$4 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        state.val = moonbitlang$core$immut$list$$T$unsafe_head$38$(state_stack.val);
        moonbitlang$core$array$$Array$push$76$(data_stack, { _0: data, _1: start_pos$2, _2: end_pos });
        let action$2;
        let count$2;
        let symbol$2;
        _L$5: {
          const _func$2 = state.val;
          const _bind$3 = _func$2(symbol);
          switch (_bind$3.$tag) {
            case 0: {
              return new Result$Ok$17$(return_(moonbitlang$core$array$$Array$unsafe_pop$76$(data_stack)._0));
            }
            case 1: {
              const _Shift = _bind$3;
              const _x = _Shift._0;
              state_stack.val = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$7$(_x, state_stack.val);
              state.val = _x;
              break _L$3;
            }
            case 2: {
              const _Reduce = _bind$3;
              const _x$2 = _Reduce._0;
              const _x$3 = _Reduce._1;
              const _x$4 = _Reduce._2;
              action$2 = _x$4;
              count$2 = _x$2;
              symbol$2 = _x$3;
              break _L$5;
            }
            case 3: {
              const _ReduceNoLookahead = _bind$3;
              const _x$5 = _ReduceNoLookahead._0;
              const _x$6 = _ReduceNoLookahead._1;
              const _x$7 = _ReduceNoLookahead._2;
              action$2 = _x$7;
              count$2 = _x$5;
              symbol$2 = _x$6;
              break _L$5;
            }
            default: {
              $panic();
              break _L$3;
            }
          }
        }
        _tmp = count$2;
        _tmp$2 = symbol$2;
        _tmp$3 = action$2;
        continue;
      }
    }
    continue;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_12(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String("");
}
function moonbitlang$lex$lib$parser$$yy_action_39(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Lex$46$YYObj__type_Lex({ header: "", named_regexes: [], rules: [], trailer: "" });
}
function moonbitlang$lex$lib$parser$$yy_state_38(_lookahead) {
  return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Accept;
}
function moonbitlang$lex$lib$parser$$yy_action_19(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_39(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 28, moonbitlang$lex$lib$parser$$yy_action_19);
}
function moonbitlang$lex$lib$parser$$yy_action_17(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__String___type_Regex__$46$YYObj__immut_list_T__String___type_Regex__($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$18$);
}
function moonbitlang$lex$lib$parser$$yy_action_15(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex($64$moonbitlang$47$lex$47$lib$47$type$46$Regex$EOF);
}
function moonbitlang$lex$lib$parser$$yy_state_13(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_15);
}
function moonbitlang$lex$lib$parser$$yy_action_36(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex($64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Underscore);
}
function moonbitlang$lex$lib$parser$$yy_state_14(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_36);
}
function moonbitlang$lex$lib$parser$$yy_action_38(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReStr(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_15(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_38);
}
function moonbitlang$lex$lib$parser$$yy_action_4(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 5) {
    const _YYObj_Char = _bind;
    const _x = _YYObj_Char._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$ReChar(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_16(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_4);
}
function moonbitlang$lex$lib$parser$$yy_action_16(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Named(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_17(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_16);
}
function moonbitlang$lex$lib$parser$$yy_action_23(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 9) {
    const _YYObj__eof_char_set_T = _bind;
    const _x = _YYObj__eof_char_set_T._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$CharSet(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_18(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 41, moonbitlang$lex$lib$parser$$yy_action_23);
}
function moonbitlang$lex$lib$parser$$yy_action_21(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
  if (_bind.$tag === 9) {
    const _YYObj__eof_char_set_T = _bind;
    const _x = _YYObj__eof_char_set_T._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_12(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 42, moonbitlang$lex$lib$parser$$yy_action_21);
}
function moonbitlang$lex$lib$parser$$yy_state_11(_lookahead) {
  if (_lookahead === 10) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_12);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_6(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 5) {
    const _YYObj_Char = _bind;
    const _x = _YYObj_Char._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(moonbitlang$lex$lib$util$eof_char_set$$singleton(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_14(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 5) {
    const _YYObj_Char = _bind;
    const _x = _YYObj_Char._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
    if (_bind$2.$tag === 5) {
      const _YYObj_Char$2 = _bind$2;
      const _x$2 = _YYObj_Char$2._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(moonbitlang$lex$lib$util$eof_char_set$$range(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_5(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 44, moonbitlang$lex$lib$parser$$yy_action_14);
}
function moonbitlang$lex$lib$parser$$yy_state_4(_lookahead) {
  if (_lookahead === 23) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_5);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_3(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 18: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_4);
      }
      case 10: {
        break _L;
      }
      case 23: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 44, moonbitlang$lex$lib$parser$$yy_action_6);
}
function moonbitlang$lex$lib$parser$$yy_action_5(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 9) {
    const _YYObj__eof_char_set_T = _bind;
    const _x = _YYObj__eof_char_set_T._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_7(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 9) {
    const _YYObj__eof_char_set_T = _bind;
    const _x = _YYObj__eof_char_set_T._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 9) {
      const _YYObj__eof_char_set_T$2 = _bind$2;
      const _x$2 = _YYObj__eof_char_set_T$2._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_add(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_7(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 43, moonbitlang$lex$lib$parser$$yy_action_7);
}
function moonbitlang$lex$lib$parser$$yy_state_6(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_3);
    }
    case 44: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_6);
    }
    case 43: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_7);
    }
    case 10: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 43, moonbitlang$lex$lib$parser$$yy_action_5);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_29(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
  if (_bind.$tag === 9) {
    const _YYObj__eof_char_set_T = _bind;
    const _x = _YYObj__eof_char_set_T._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__eof_char_set_T$46$YYObj__eof_char_set_T(moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$negated(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_10(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 42, moonbitlang$lex$lib$parser$$yy_action_29);
}
function moonbitlang$lex$lib$parser$$yy_state_9(_lookahead) {
  if (_lookahead === 10) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_10);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_8(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_3);
    }
    case 44: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_6);
    }
    case 43: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_9);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_2(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_3);
    }
    case 44: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_6);
    }
    case 19: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_8);
    }
    case 43: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_11);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_20(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_21(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 41, moonbitlang$lex$lib$parser$$yy_action_20);
}
function moonbitlang$lex$lib$parser$$yy_state_20(_lookahead) {
  if (_lookahead === 8) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_21);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_18(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_1(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Option(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_23(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 40, moonbitlang$lex$lib$parser$$yy_action_1);
}
function moonbitlang$lex$lib$parser$$yy_action_24(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Repetition(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_24(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 40, moonbitlang$lex$lib$parser$$yy_action_24);
}
function moonbitlang$lex$lib$parser$$yy_action_3(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Option(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Repetition(_x)));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_25(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 40, moonbitlang$lex$lib$parser$$yy_action_3);
}
function moonbitlang$lex$lib$parser$$yy_state_22(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 17: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_23);
      }
      case 16: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_24);
      }
      case 15: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_25);
      }
      case 0: {
        break _L;
      }
      case 1: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 24: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 40, moonbitlang$lex$lib$parser$$yy_action_18);
}
function moonbitlang$lex$lib$parser$$yy_action_25(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_32(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 8) {
      const _YYObj__type_Regex$2 = _bind$2;
      const _x$2 = _YYObj__type_Regex$2._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Concat(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_27(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 39, moonbitlang$lex$lib$parser$$yy_action_32);
}
function moonbitlang$lex$lib$parser$$yy_action_33(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_11(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
    if (_bind$2.$tag === 8) {
      const _YYObj__type_Regex$2 = _bind$2;
      const _x$2 = _YYObj__type_Regex$2._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Alter(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_30(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 38, moonbitlang$lex$lib$parser$$yy_action_11);
}
function moonbitlang$lex$lib$parser$$yy_action_28(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_34(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
    if (_bind$2.$tag === 4) {
      const _YYObj_String = _bind$2;
      const _x$2 = _YYObj_String._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(new $64$moonbitlang$47$lex$47$lib$47$type$46$Regex$Capture(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_33(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 37, moonbitlang$lex$lib$parser$$yy_action_34);
}
function moonbitlang$lex$lib$parser$$yy_state_32(_lookahead) {
  if (_lookahead === 22) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_33);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_31(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 4: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_32);
      }
      case 0: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 37, moonbitlang$lex$lib$parser$$yy_action_28);
}
function moonbitlang$lex$lib$parser$$yy_state_19(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
    }
    case 1: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
    }
    case 5: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
    }
    case 24: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
    }
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
    }
    case 22: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
    }
    case 42: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
    }
    case 7: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
    }
    case 37: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_20);
    }
    case 41: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
    }
    case 40: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
    }
    case 39: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_28);
    }
    case 38: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_31);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_26(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 9: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
      }
      case 1: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
      }
      case 5: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
      }
      case 24: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
      }
      case 23: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
      }
      case 22: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
      }
      case 42: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
      }
      case 7: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
      }
      case 41: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
      }
      case 40: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
      }
      case 39: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_27);
      }
      case 0: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 39, moonbitlang$lex$lib$parser$$yy_action_25);
}
function moonbitlang$lex$lib$parser$$yy_state_28(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 14: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_29);
      }
      case 0: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 38, moonbitlang$lex$lib$parser$$yy_action_33);
}
function moonbitlang$lex$lib$parser$$yy_state_29(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
    }
    case 1: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
    }
    case 5: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
    }
    case 24: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
    }
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
    }
    case 22: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
    }
    case 42: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
    }
    case 7: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
    }
    case 41: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
    }
    case 40: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
    }
    case 39: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_28);
    }
    case 38: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_30);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_31(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Regex$46$YYObj__type_Regex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_34(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 36, moonbitlang$lex$lib$parser$$yy_action_31);
}
function moonbitlang$lex$lib$parser$$yy_action_30(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 3)._0;
    if (_bind$2.$tag === 8) {
      const _YYObj__type_Regex = _bind$2;
      const _x$2 = _YYObj__type_Regex._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__String___type_Regex_$46$YYObj__String___type_Regex_({ _0: _x, _1: _x$2 });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_45(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 31, moonbitlang$lex$lib$parser$$yy_action_30);
}
function moonbitlang$lex$lib$parser$$yy_state_44(_lookahead) {
  if (_lookahead === 12) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_45);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_43(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
    }
    case 1: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
    }
    case 5: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
    }
    case 24: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
    }
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
    }
    case 22: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
    }
    case 42: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
    }
    case 7: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
    }
    case 41: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
    }
    case 40: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
    }
    case 39: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_28);
    }
    case 38: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_31);
    }
    case 37: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_34);
    }
    case 36: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_44);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_42(_lookahead) {
  if (_lookahead === 11) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_43);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_41(_lookahead) {
  if (_lookahead === 22) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_42);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_0(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 10) {
    const _YYObj__String___type_Regex_ = _bind;
    const _x = _YYObj__String___type_Regex_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 7) {
      const _YYObj__immut_list_T__String___type_Regex__ = _bind$2;
      const _x$2 = _YYObj__immut_list_T__String___type_Regex__._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__String___type_Regex__$46$YYObj__immut_list_T__String___type_Regex__(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$18$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_47(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 30, moonbitlang$lex$lib$parser$$yy_action_0);
}
function moonbitlang$lex$lib$parser$$yy_state_46(_lookahead) {
  switch (_lookahead) {
    case 3: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_41);
    }
    case 31: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_46);
    }
    case 30: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_47);
    }
    case 20: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 30, moonbitlang$lex$lib$parser$$yy_action_17);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_27(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$19$);
}
function moonbitlang$lex$lib$parser$$yy_action_37(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj__type_Regex = _bind;
    const _x = _YYObj__type_Regex._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
    if (_bind$2.$tag === 4) {
      const _YYObj_String = _bind$2;
      const _x$2 = _YYObj_String._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj___type_Regex___type_CodeBlock_$46$YYObj___type_Regex___type_CodeBlock_({ _0: _x, _1: _x$2 });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_53(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 35, moonbitlang$lex$lib$parser$$yy_action_37);
}
function moonbitlang$lex$lib$parser$$yy_state_52(_lookahead) {
  if (_lookahead === 21) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_53);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_51(_lookahead) {
  if (_lookahead === 13) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_52);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_8(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 12) {
    const _YYObj___type_Regex___type_CodeBlock_ = _bind;
    const _x = _YYObj___type_Regex___type_CodeBlock_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 11) {
      const _YYObj__immut_list_T___type_Regex___type_CodeBlock__ = _bind$2;
      const _x$2 = _YYObj__immut_list_T___type_Regex___type_CodeBlock__._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__$46$YYObj__immut_list_T___type_Regex___type_CodeBlock__(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$19$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_55(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 34, moonbitlang$lex$lib$parser$$yy_action_8);
}
function moonbitlang$lex$lib$parser$$yy_state_54(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
    }
    case 1: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
    }
    case 5: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
    }
    case 24: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
    }
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
    }
    case 22: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
    }
    case 42: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
    }
    case 7: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
    }
    case 41: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
    }
    case 40: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
    }
    case 39: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_28);
    }
    case 38: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_31);
    }
    case 37: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_34);
    }
    case 36: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_51);
    }
    case 35: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_54);
    }
    case 34: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_55);
    }
    case 6: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 34, moonbitlang$lex$lib$parser$$yy_action_27);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_22(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 3) {
    const _YYObj__String__String_ = _bind;
    const _x = _YYObj__String__String_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
    if (_bind$2.$tag === 11) {
      const _YYObj__immut_list_T___type_Regex___type_CodeBlock__ = _bind$2;
      const _x$2 = _YYObj__immut_list_T___type_Regex___type_CodeBlock__._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Rule$46$YYObj__type_Rule({ name: _x._0, signature: _x._1, patterns: moonbitlang$core$immut$list$$T$to_array$35$(_x$2) });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_58(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 33, moonbitlang$lex$lib$parser$$yy_action_22);
}
function moonbitlang$lex$lib$parser$$yy_state_57(_lookahead) {
  if (_lookahead === 6) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_58);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_56(_lookahead) {
  if (_lookahead === 6) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_57);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_50(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_2);
    }
    case 1: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_13);
    }
    case 5: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_14);
    }
    case 24: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_15);
    }
    case 23: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_16);
    }
    case 22: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_17);
    }
    case 42: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_18);
    }
    case 7: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_19);
    }
    case 41: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_22);
    }
    case 40: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_26);
    }
    case 39: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_28);
    }
    case 38: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_31);
    }
    case 37: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_34);
    }
    case 36: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_51);
    }
    case 35: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_54);
    }
    case 34: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_56);
    }
    case 6: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 34, moonbitlang$lex$lib$parser$$yy_action_27);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_49(_lookahead) {
  if (_lookahead === 2) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_50);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_action_13(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 13) {
    const _YYObj__type_Rule = _bind;
    const _x = _YYObj__type_Rule._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__type_Rule_$46$YYObj__immut_list_T__type_Rule_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$20$(_x, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$20$));
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_action_2(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 13) {
    const _YYObj__type_Rule = _bind;
    const _x = _YYObj__type_Rule._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 14) {
      const _YYObj__immut_list_T__type_Rule_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T__type_Rule_._0;
      return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__immut_list_T__type_Rule_$46$YYObj__immut_list_T__type_Rule_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$20$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_60(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$lex$lib$parser$$yy_action_2);
}
function moonbitlang$lex$lib$parser$$yy_state_59(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 20: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_49);
      }
      case 33: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_59);
      }
      case 32: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_60);
      }
      case 0: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(1, 32, moonbitlang$lex$lib$parser$$yy_action_13);
}
function moonbitlang$lex$lib$parser$$yy_action_26(_last_pos, _args) {
  return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String("");
}
function moonbitlang$lex$lib$parser$$yy_action_40(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_62(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 29, moonbitlang$lex$lib$parser$$yy_action_40);
}
function moonbitlang$lex$lib$parser$$yy_action_35(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 1)._0;
    if (_bind$2.$tag === 7) {
      const _YYObj__immut_list_T__String___type_Regex__ = _bind$2;
      const _x$2 = _YYObj__immut_list_T__String___type_Regex__._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 2)._0;
      if (_bind$3.$tag === 14) {
        const _YYObj__immut_list_T__type_Rule_ = _bind$3;
        const _x$3 = _YYObj__immut_list_T__type_Rule_._0;
        const _bind$4 = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 3)._0;
        if (_bind$4.$tag === 4) {
          const _YYObj_String$2 = _bind$4;
          const _x$4 = _YYObj_String$2._0;
          return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Lex$46$YYObj__type_Lex({ header: _x, named_regexes: moonbitlang$core$immut$list$$T$to_array$37$(_x$2), rules: moonbitlang$core$immut$list$$T$to_array$36$(_x$3), trailer: _x$4 });
        } else {
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_63(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 27, moonbitlang$lex$lib$parser$$yy_action_35);
}
function moonbitlang$lex$lib$parser$$yy_state_61(_lookahead) {
  switch (_lookahead) {
    case 21: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_62);
    }
    case 29: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_63);
    }
    case 0: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 29, moonbitlang$lex$lib$parser$$yy_action_26);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_48(_lookahead) {
  switch (_lookahead) {
    case 20: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_49);
    }
    case 33: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_59);
    }
    case 32: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_61);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_state_40(_lookahead) {
  switch (_lookahead) {
    case 3: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_41);
    }
    case 31: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_46);
    }
    case 30: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_48);
    }
    case 20: {
      return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 30, moonbitlang$lex$lib$parser$$yy_action_17);
    }
    default: {
      return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$lex$lib$parser$$yy_action_9(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$76$(_args, 0)._0;
  if (_bind.$tag === 6) {
    const _YYObj__type_Lex = _bind;
    const _x = _YYObj__type_Lex._0;
    return new Error$moonbitlang$47$lex$47$lib$47$parser$46$YYObj__type_Lex$46$YYObj__type_Lex(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$lex$lib$parser$$yy_state_65(_lookahead) {
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 25, moonbitlang$lex$lib$parser$$yy_action_9);
}
function moonbitlang$lex$lib$parser$$yy_state_64(_lookahead) {
  if (_lookahead === 0) {
    return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_65);
  } else {
    return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$lex$lib$parser$$yy_state_37(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 25: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_38);
      }
      case 21: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_39);
      }
      case 28: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_40);
      }
      case 27: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$lex$lib$parser$$yy_state_64);
      }
      case 0: {
        return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 27, moonbitlang$lex$lib$parser$$yy_action_39);
      }
      case 3: {
        break _L;
      }
      case 20: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$lex$47$lib$47$parser$46$YYDecision$Reduce(0, 28, moonbitlang$lex$lib$parser$$yy_action_12);
}
function moonbitlang$lex$lib$parser$$lex_eoi(read_token, start_pos) {
  return moonbitlang$lex$lib$parser$$yy_parse$148$(read_token, start_pos, moonbitlang$lex$lib$parser$$yy_state_37, (_param1) => {
    if (_param1.$tag === 6) {
      const _YYObj__type_Lex = _param1;
      const _x = _YYObj__type_Lex._0;
      return _x;
    } else {
      return $panic();
    }
  });
}
function moonbitlang$lex$lib$parser$$parse_lex_from_string(input) {
  const arg = moonbitlang$lex$45$runtime$lexbuf$$from_string$46$start$46$default();
  const arg$2 = moonbitlang$lex$45$runtime$lexbuf$$from_string$46$end$46$default(input);
  const lexbuf = moonbitlang$lex$45$runtime$lexbuf$$from_string(input, arg, arg$2);
  return moonbitlang$lex$lib$parser$$lex_eoi(() => {
    const tok = moonbitlang$lex$lib$parser$$token$147$(lexbuf);
    return { _0: tok, _1: undefined, _2: undefined };
  }, undefined);
}
function moonbitlang$core$builtin$$Show$output$69$(self, logger) {
  let _tmp;
  switch (self) {
    case 0: {
      _tmp = "EOI";
      break;
    }
    case 1: {
      _tmp = "\"eof\"";
      break;
    }
    case 2: {
      _tmp = "\"parse {\"";
      break;
    }
    case 3: {
      _tmp = "\"let\"";
      break;
    }
    case 4: {
      _tmp = "\"as\"";
      break;
    }
    case 5: {
      _tmp = "\"_\"";
      break;
    }
    case 6: {
      _tmp = "\"}\"";
      break;
    }
    case 7: {
      _tmp = "\"(\"";
      break;
    }
    case 8: {
      _tmp = "\")\"";
      break;
    }
    case 9: {
      _tmp = "\"[\"";
      break;
    }
    case 10: {
      _tmp = "\"]\"";
      break;
    }
    case 11: {
      _tmp = "\"=\"";
      break;
    }
    case 12: {
      _tmp = "\";\"";
      break;
    }
    case 13: {
      _tmp = "\"=>\"";
      break;
    }
    case 14: {
      _tmp = "\"|\"";
      break;
    }
    case 15: {
      _tmp = "\"*\"";
      break;
    }
    case 16: {
      _tmp = "\"+\"";
      break;
    }
    case 17: {
      _tmp = "\"?\"";
      break;
    }
    case 18: {
      _tmp = "\"-\"";
      break;
    }
    case 19: {
      _tmp = "\"^\"";
      break;
    }
    case 20: {
      _tmp = "RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE";
      break;
    }
    case 21: {
      _tmp = "LBRACE_CODE_RBRACE";
      break;
    }
    case 22: {
      _tmp = "LC_IDENT";
      break;
    }
    case 23: {
      _tmp = "CHAR";
      break;
    }
    default: {
      _tmp = "STRING";
    }
  }
  logger.method_0(logger.self, _tmp);
}
(() => {
})();
function moonbitlang$core$builtin$$Eq$op_equal$74$(_x_21, _x_22) {
  return moonbitlang$core$builtin$$Eq$op_equal$26$(_x_21.bits, _x_22.bits) && _x_21.len === _x_22.len;
}
function moonbitlang$lex$lib$util$bitset$$new(len) {
  return { bits: moonbitlang$core$array$$FixedArray$makei$5$((len + 32 | 0) / 32 | 0, (_i) => 0), len: len };
}
function moonbitlang$lex$lib$util$bitset$$Bitset$copy(self) {
  return { bits: moonbitlang$core$array$$FixedArray$copy$5$(self.bits), len: self.len };
}
function moonbitlang$lex$lib$util$bitset$$Bitset$get(self, index) {
  return (self.bits[index / 32 | 0] & 1 << (index % 32 | 0)) !== 0;
}
function moonbitlang$lex$lib$util$bitset$$Bitset$set(self, index, value) {
  const t = index / 32 | 0;
  self.bits[t] = self.bits[t] | moonbitlang$core$bool$$Bool$to_int(value) << index;
}
function moonbitlang$lex$lib$util$bitset$$Bitset$union(self, other) {
  return self.len !== other.len ? moonbitlang$core$builtin$$abort$74$("") : { bits: moonbitlang$core$array$$FixedArray$makei$5$(self.bits.length, (i) => self.bits[i] | other.bits[i]), len: self.len };
}
function moonbitlang$core$builtin$$Eq$op_equal$46$(_x_274, _x_275) {
  return moonbitlang$core$builtin$$Eq$op_equal$140$(_x_274, _x_275);
}
function moonbitlang$core$builtin$$Hash$hash_combine$46$(self, hasher) {
  moonbitlang$core$array$$Array$each$25$(self, (x) => {
    moonbitlang$core$builtin$$Hasher$combine$25$(hasher, x);
  });
}
function moonbitlang$core$builtin$$Compare$compare$46$(self, other) {
  return moonbitlang$core$builtin$$Compare$compare$140$(self, other);
}
function moonbitlang$lex$lib$automaton$$TagState$new(size) {
  return moonbitlang$core$array$$Array$make$25$(size, undefined);
}
function moonbitlang$lex$lib$automaton$$TagState$copy(self) {
  return moonbitlang$core$array$$Array$copy$25$(self);
}
function moonbitlang$lex$lib$automaton$$TagState$update_by_tag(self, tag, rank) {
  const r = moonbitlang$core$array$$Array$op_get$25$(self, tag);
  if (moonbitlang$core$option$$Option$is_empty$5$(r) || moonbitlang$core$option$$Option$unwrap$5$(r) > rank) {
    moonbitlang$core$array$$Array$op_set$25$(self, tag, rank);
  }
  return self;
}
function moonbitlang$lex$lib$automaton$$TagState$update_by_tags(self, tags) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < self.length) {
      if (moonbitlang$lex$lib$util$bitset$$Bitset$get(tags, i)) {
        moonbitlang$lex$lib$automaton$$TagState$update_by_tag(self, i, -1);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return self;
}
function moonbitlang$lex$lib$automaton$$TagState$tagState_min(self, other) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < self.length) {
      const _bind = moonbitlang$core$array$$Array$op_get$25$(self, i);
      const _bind$2 = moonbitlang$core$array$$Array$op_get$25$(other, i);
      if (_bind === undefined) {
        return other;
      } else {
        if (_bind$2 === undefined) {
          return self;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _Some$2 = _bind$2;
          const _x$2 = _Some$2;
          if (_x !== _x$2) {
            return _x < _x$2 ? self : other;
          }
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return self;
    }
  }
}
function moonbitlang$lex$lib$automaton$$DFA$new(code_blocks, captures, start_action) {
  return { graph: [], end_nodes: moonbitlang$core$builtin$$Map$new$97$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$97$()), code_blocks: code_blocks, captures: captures, start_action: start_action, node_count: 0 };
}
function moonbitlang$lex$lib$automaton$$DFA$new_node(self) {
  const id = self.node_count;
  self.node_count = self.node_count + 1 | 0;
  moonbitlang$core$array$$Array$push$88$(self.graph, []);
  return id;
}
function moonbitlang$lex$lib$automaton$$DFA$add_edge(self, from, e, action, to) {
  moonbitlang$core$array$$Array$push$118$(moonbitlang$core$array$$Array$op_get$88$(self.graph, from), { _0: e, _1: { _0: to, _1: action } });
}
function moonbitlang$lex$lib$automaton$$state_canonicalize(state, tag_count) {
  const mat = moonbitlang$core$array$$Array$makei$21$(tag_count, (_i) => []);
  const _bind = moonbitlang$core$immut$hashmap$$T$iter$40$(state);
  _bind((pair) => {
    const tags = pair._1;
    const _arr = tags;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const rank = _arr[_i];
        if (!moonbitlang$core$option$$Option$is_empty$5$(rank)) {
          moonbitlang$core$array$$Array$push$5$(moonbitlang$core$array$$Array$op_get$21$(mat, _i), moonbitlang$core$option$$Option$unwrap$5$(rank));
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 1;
  });
  moonbitlang$core$array$$Array$map_inplace$21$(mat, (x) => moonbitlang$core$sorted_set$$T$to_array$5$(moonbitlang$core$sorted_set$$from_iter$5$(moonbitlang$core$array$$Array$iter$5$(x))));
  const _bind$2 = moonbitlang$core$immut$hashmap$$T$iter$40$(state);
  const new_state = moonbitlang$core$immut$hashmap$$from_iter$40$((_p) => _bind$2((_p$2) => {
    const tags = _p$2._1;
    moonbitlang$core$array$$Array$mapi_inplace$25$(tags, (tag, op) => moonbitlang$core$option$$Option$map$47$(op, (x) => {
      const _arr = moonbitlang$core$array$$Array$op_get$21$(mat, tag);
      const _len = _arr.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const y = _arr[_i];
          if (x === y) {
            return _i;
          }
          _tmp = _i + 1 | 0;
          continue;
        } else {
          return moonbitlang$core$builtin$$abort$5$("unreachable");
        }
      }
    }));
    return _p({ _0: _p$2._0, _1: tags });
  }));
  return { _0: new_state, _1: mat };
}
function moonbitlang$lex$lib$automaton$$DFA$register_node(self, nfa, node, os) {
  const code_blocks = moonbitlang$core$builtin$$Iter$collect$5$(moonbitlang$core$builtin$$Iter$filter_map$143$(moonbitlang$core$immut$hashmap$$T$iter$40$(os), (x) => moonbitlang$core$builtin$$Map$get$47$(nfa.end_nodes, x._0.num)));
  if (!moonbitlang$core$array$$Array$is_empty$5$(code_blocks)) {
    const min_code_block = moonbitlang$core$array$$Array$fold$47$(code_blocks, moonbitlang$core$array$$Array$op_get$5$(code_blocks, 0), moonbitlang$core$math$$minimum$5$);
    const _bind = moonbitlang$core$immut$hashmap$$T$iter$40$(os);
    const end_nodes = moonbitlang$core$builtin$$Iter$to_array$44$((_p) => _bind((_p$2) => moonbitlang$core$builtin$$Eq$op_equal$49$(moonbitlang$core$builtin$$Map$get$47$(nfa.end_nodes, _p$2._0.num), min_code_block) ? _p(_p$2) : 1));
    if (end_nodes.length === 1) {
      const tagState = moonbitlang$core$array$$Array$op_get$44$(end_nodes, 0)._1;
      const min_tags = moonbitlang$core$array$$Array$map$123$(moonbitlang$core$array$$Array$op_get$87$(nfa.captures, min_code_block), (_param1) => {
        const _x = _param1._1;
        const _x$2 = _x._0;
        const _x$3 = _x._1;
        return { _0: { _0: _x$2, _1: moonbitlang$core$option$$Option$unwrap$5$(moonbitlang$core$array$$Array$op_get$25$(tagState, _x$2)) }, _1: { _0: _x$3, _1: moonbitlang$core$option$$Option$unwrap$5$(moonbitlang$core$array$$Array$op_get$25$(tagState, _x$3)) } };
      });
      moonbitlang$core$builtin$$Map$set$97$(self.end_nodes, node, { _0: min_code_block, _1: min_tags });
      return;
    } else {
      moonbitlang$core$builtin$$abort$4$("error");
      return;
    }
  } else {
    return;
  }
}
function moonbitlang$lex$lib$automaton$$get_eps_closure$46$get_bits$149$(_env, n) {
  const empty_bits = _env._1;
  const result = _env._0;
  return moonbitlang$core$builtin$$Map$get_or_default$39$(result, n, empty_bits);
}
function moonbitlang$lex$lib$automaton$$NFA$get_eps_closure(self) {
  return moonbitlang$core$array$$Array$map$124$(self.graph, (x) => {
    const empty_bits = moonbitlang$lex$lib$util$bitset$$new(self.tag_count);
    const result = moonbitlang$core$builtin$$Map$from_array$39$([{ _0: x, _1: empty_bits }]);
    const _env = { _0: result, _1: empty_bits };
    const queue = moonbitlang$core$queue$$from_array$41$([x]);
    while (true) {
      if (!moonbitlang$core$queue$$T$is_empty$41$(queue)) {
        const o = moonbitlang$core$queue$$T$unsafe_pop$41$(queue);
        const o_bits = moonbitlang$lex$lib$automaton$$get_eps_closure$46$get_bits$149$(_env, o);
        const _bind = moonbitlang$core$immut$sorted_set$$T$iter$27$(o.eps);
        _bind((e) => {
          const _x = e._0;
          const _x$2 = e._1;
          let new_u_bits = moonbitlang$lex$lib$util$bitset$$Bitset$union(moonbitlang$lex$lib$automaton$$get_eps_closure$46$get_bits$149$(_env, _x), o_bits);
          if (!moonbitlang$core$option$$Option$is_empty$5$(_x$2)) {
            new_u_bits = moonbitlang$lex$lib$util$bitset$$Bitset$copy(new_u_bits);
            moonbitlang$lex$lib$util$bitset$$Bitset$set(new_u_bits, moonbitlang$core$option$$Option$unwrap$5$(_x$2), true);
          }
          if (moonbitlang$core$builtin$$op_notequal$82$(new_u_bits, moonbitlang$core$builtin$$Map$get$39$(result, _x))) {
            moonbitlang$core$builtin$$Map$set$39$(result, _x, new_u_bits);
            moonbitlang$core$queue$$T$push$41$(queue, _x);
          }
          return 1;
        });
        continue;
      } else {
        break;
      }
    }
    return moonbitlang$core$immut$hashmap$$from_iter$39$(moonbitlang$core$builtin$$Map$iter$39$(result));
  });
}
function moonbitlang$lex$lib$automaton$$from_nfa$46$get_id$150$(_env, state) {
  const node_map = _env._3;
  const dfa = _env._2;
  const nfa = _env._1;
  const queue = _env._0;
  return moonbitlang$core$builtin$$Map$get_or_init$101$(node_map, state, () => {
    const node = moonbitlang$lex$lib$automaton$$DFA$new_node(dfa);
    moonbitlang$lex$lib$automaton$$DFA$register_node(dfa, nfa, node, state);
    moonbitlang$core$queue$$T$push$24$(queue, state);
    return node;
  });
}
function moonbitlang$lex$lib$automaton$$from_nfa$46$42$func$151$(_env, _p) {
  const _x = _env._1;
  const _bind = _env._0;
  return _bind((_p$2) => {
    const _x$2 = _p$2._0;
    const _x$3 = _p$2._1;
    const _x$4 = _x$3._0;
    const _x$5 = _x$3._1;
    return _p({ _0: _x$2, _1: { _0: _x$4, _1: _x, _2: _x$5 } });
  });
}
function moonbitlang$lex$lib$automaton$$from_nfa$46$add_tran$152$(new_nfa_trans, cset, targets) {
  if (!moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$is_empty(cset)) {
    moonbitlang$core$array$$Array$push$117$(new_nfa_trans, { _0: cset, _1: targets });
    return;
  } else {
    return;
  }
}
function moonbitlang$lex$lib$automaton$$DFA$from_nfa(nfa) {
  const eps_closure = moonbitlang$lex$lib$automaton$$NFA$get_eps_closure(nfa);
  const initial = moonbitlang$core$array$$Array$op_get$23$(eps_closure, 0);
  const _bind = moonbitlang$core$immut$hashmap$$T$iter$39$(initial);
  const initial_state = moonbitlang$core$immut$hashmap$$from_iter$40$((_p) => _bind((_p$2) => {
    const _x = _p$2._0;
    const _x$2 = _p$2._1;
    return _p({ _0: _x, _1: moonbitlang$lex$lib$automaton$$TagState$update_by_tags(moonbitlang$lex$lib$automaton$$TagState$new(nfa.tag_count), _x$2) });
  }));
  const _bind$2 = moonbitlang$lex$lib$automaton$$state_canonicalize(initial_state, nfa.tag_count);
  const _x = _bind$2._0;
  const _x$2 = _bind$2._1;
  const captures = moonbitlang$core$array$$Array$map$126$(nfa.captures, (x) => moonbitlang$core$array$$Array$map$125$(x, (y) => y._0));
  const dfa = moonbitlang$lex$lib$automaton$$DFA$new(nfa.code_blocks, captures, _x$2);
  const node_map = moonbitlang$core$builtin$$Map$new$101$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$101$());
  const queue = moonbitlang$core$queue$$new$24$();
  const _env = { _0: queue, _1: nfa, _2: dfa, _3: node_map };
  moonbitlang$lex$lib$automaton$$from_nfa$46$get_id$150$(_env, _x);
  while (true) {
    if (!moonbitlang$core$queue$$T$is_empty$24$(queue)) {
      const cur_state = moonbitlang$core$option$$Option$unwrap$24$(moonbitlang$core$queue$$T$pop$24$(queue));
      const from_n = moonbitlang$core$option$$Option$unwrap$5$(moonbitlang$core$builtin$$Map$get$101$(node_map, cur_state));
      const _bind$3 = moonbitlang$core$immut$hashmap$$T$iter$40$(cur_state);
      const char_set_by_nfa_target = moonbitlang$core$builtin$$Map$from_array$96$([]);
      const _p = (nfa_tran) => {
        const _x$3 = nfa_tran._0;
        const _x$4 = nfa_tran._1;
        const _bind$4 = moonbitlang$core$builtin$$Map$op_get$96$(char_set_by_nfa_target, _x$4);
        if (_bind$4 === undefined) {
          moonbitlang$core$builtin$$Map$op_set$96$(char_set_by_nfa_target, _x$4, _x$3);
        } else {
          const _Some = _bind$4;
          const _x$5 = _Some;
          moonbitlang$core$builtin$$Map$op_set$96$(char_set_by_nfa_target, _x$4, moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_add(_x$5, _x$3));
        }
        return 1;
      };
      _bind$3((_p$2) => {
        const _x$3 = _p$2._0;
        const _x$4 = _p$2._1;
        const _bind$4 = moonbitlang$core$array$$Array$iter$114$(_x$3.trans);
        const _env$2 = { _0: _bind$4, _1: _x$4 };
        return moonbitlang$lex$lib$automaton$$from_nfa$46$42$func$151$(_env$2, _p);
      });
      const nfa_trans = { val: [] };
      const all_char_set = { val: moonbitlang$lex$lib$util$eof_char_set$$empty };
      const _bind$4 = moonbitlang$core$builtin$$Map$iter2$96$(char_set_by_nfa_target);
      _bind$4((target, char_set) => {
        const targets = moonbitlang$core$immut$sorted_set$$singleton$28$(target);
        const new_nfa_trans = [];
        moonbitlang$lex$lib$automaton$$from_nfa$46$add_tran$152$(new_nfa_trans, moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_sub(char_set, all_char_set.val), targets);
        const _arr = nfa_trans.val;
        const _len = _arr.length;
        let _tmp = 0;
        while (true) {
          const _i = _tmp;
          if (_i < _len) {
            const nfa_tran = _arr[_i];
            const _x$3 = nfa_tran._0;
            const _x$4 = nfa_tran._1;
            moonbitlang$lex$lib$automaton$$from_nfa$46$add_tran$152$(new_nfa_trans, moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$land(_x$3, char_set), moonbitlang$core$immut$sorted_set$$T$op_add$28$(_x$4, targets));
            moonbitlang$lex$lib$automaton$$from_nfa$46$add_tran$152$(new_nfa_trans, moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_sub(_x$3, char_set), _x$4);
            _tmp = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        all_char_set.val = moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$op_add(all_char_set.val, char_set);
        nfa_trans.val = new_nfa_trans;
        return 1;
      });
      const next_states = moonbitlang$core$builtin$$Map$new$100$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$100$());
      const _arr = nfa_trans.val;
      const _len = _arr.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const tran = _arr[_i];
          const _x$3 = tran._0;
          const _x$4 = tran._1;
          const _bind$5 = moonbitlang$core$immut$sorted_set$$T$iter$28$(_x$4);
          _bind$5((target) => {
            const _x$5 = target._0;
            const _x$6 = target._1;
            const _x$7 = target._2;
            const state_map = { val: moonbitlang$core$option$$Option$or_else$24$(moonbitlang$core$builtin$$Map$op_get$100$(next_states, _x$3), () => moonbitlang$core$immut$hashmap$$new$40$()) };
            if (moonbitlang$core$option$$Option$is_empty$5$(_x$7)) {
              const _bind$6 = moonbitlang$core$immut$hashmap$$T$iter$39$(moonbitlang$core$array$$Array$op_get$23$(eps_closure, _x$5.num));
              _bind$6((pair) => {
                const _x$8 = pair._0;
                const _x$9 = pair._1;
                const upd_tagState = moonbitlang$lex$lib$automaton$$TagState$update_by_tags(moonbitlang$lex$lib$automaton$$TagState$copy(_x$6), _x$9);
                const old_tagState = moonbitlang$core$immut$hashmap$$T$op_get$40$(state_map.val, _x$8);
                const new_tagState = moonbitlang$core$option$$Option$is_empty$46$(old_tagState) ? upd_tagState : moonbitlang$lex$lib$automaton$$TagState$tagState_min(upd_tagState, moonbitlang$core$option$$Option$unwrap$46$(old_tagState));
                state_map.val = moonbitlang$core$immut$hashmap$$T$add$40$(state_map.val, _x$8, new_tagState);
                return 1;
              });
              moonbitlang$core$builtin$$Map$op_set$100$(next_states, _x$3, state_map.val);
            } else {
              moonbitlang$core$builtin$$abort$4$("error");
            }
            return 1;
          });
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const trans = moonbitlang$core$builtin$$Iter$to_array$113$(moonbitlang$core$builtin$$Map$iter$100$(next_states));
      const _len$2 = trans.length;
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len$2) {
          const tran = trans[_i];
          const _x$3 = tran._0;
          const _x$4 = tran._1;
          const _bind$5 = moonbitlang$lex$lib$automaton$$state_canonicalize(_x$4, nfa.tag_count);
          const _x$5 = _bind$5._0;
          const _x$6 = _bind$5._1;
          const to_n = moonbitlang$lex$lib$automaton$$from_nfa$46$get_id$150$(_env, _x$5);
          moonbitlang$lex$lib$automaton$$DFA$add_edge(dfa, from_n, _x$3, _x$6, to_n);
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      continue;
    } else {
      break;
    }
  }
  return dfa;
}
function moonbitlang$lex$lib$automaton$$NFA$new_nfa() {
  return { graph: [], end_nodes: moonbitlang$core$builtin$$Map$new$47$(moonbitlang$core$builtin$$Map$new$46$capacity$46$default$47$()), code_blocks: [], captures: [], node_count: 0, tag_count: 0 };
}
function moonbitlang$lex$lib$automaton$$NFA$new_node(self) {
  const new_id = self.node_count;
  self.node_count = self.node_count + 1 | 0;
  const node = { num: new_id, eps: moonbitlang$core$immut$sorted_set$$new$27$(), trans: [] };
  moonbitlang$core$array$$Array$push$41$(self.graph, node);
  return (new_id + 1 | 0) === self.graph.length ? node : $panic();
}
function moonbitlang$lex$lib$automaton$$NFA$add_edge(self, from, s, tag, to) {
  if (s.$tag === 0) {
    from.eps = moonbitlang$core$immut$sorted_set$$T$add$27$(from.eps, { _0: to, _1: tag });
    return;
  } else {
    const _EChar = s;
    const _x = _EChar._0;
    moonbitlang$core$array$$Array$push$114$(from.trans, { _0: _x, _1: { _0: to, _1: tag } });
    return;
  }
}
function moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default() {
  return undefined;
}
function moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self, node, re, name2tag) {
  let _tmp = self;
  let _tmp$2 = node;
  let _tmp$3 = re;
  let _tmp$4 = name2tag;
  _L: while (true) {
    const self$2 = _tmp;
    const node$2 = _tmp$2;
    const re$2 = _tmp$3;
    const name2tag$2 = _tmp$4;
    switch (re$2.$tag) {
      case 0: {
        const next_node = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, new $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(moonbitlang$lex$lib$util$eof_char_set$$any), moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), next_node);
        return next_node;
      }
      case 1: {
        const next_node$2 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, new $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(moonbitlang$lex$lib$util$eof_char_set$$eof), moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), next_node$2);
        return next_node$2;
      }
      case 3: {
        const _ReChar = re$2;
        const _x = _ReChar._0;
        const next_node$3 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, new $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(moonbitlang$lex$lib$util$eof_char_set$$singleton(_x)), moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), next_node$3);
        return next_node$3;
      }
      case 2: {
        const _ReStr = re$2;
        const _x$2 = _ReStr._0;
        const next_node$4 = { val: node$2 };
        const last_node = { val: node$2 };
        const _bind = moonbitlang$core$string$$String$iter(_x$2);
        _bind((c) => {
          next_node$4.val = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
          moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, last_node.val, new $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(moonbitlang$lex$lib$util$eof_char_set$$singleton(c)), moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), next_node$4.val);
          last_node.val = next_node$4.val;
          return 1;
        });
        return next_node$4.val;
      }
      case 4: {
        const _CharSet = re$2;
        const _x$3 = _CharSet._0;
        const next_node$5 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, new $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$EChar(_x$3), moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), next_node$5);
        return next_node$5;
      }
      case 6: {
        const _Option = re$2;
        const _x$4 = _Option._0;
        const new_node = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        const final_ = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, new_node, _x$4, name2tag$2);
        const new_final = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), new_node);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, final_, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), new_final);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), new_final);
        return new_final;
      }
      case 5: {
        const _Repetition = re$2;
        const _x$5 = _Repetition._0;
        const new_node$2 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        const final_$2 = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, new_node$2, _x$5, name2tag$2);
        const new_final$2 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), new_node$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, final_$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), new_final$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, new_final$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), node$2);
        return new_final$2;
      }
      case 8: {
        const _Concat = re$2;
        const _x$6 = _Concat._0;
        const _x$7 = _Concat._1;
        const mid = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, node$2, _x$6, name2tag$2);
        _tmp$2 = mid;
        _tmp$3 = _x$7;
        continue _L;
      }
      case 7: {
        const _Alter = re$2;
        const _x$8 = _Alter._0;
        const _x$9 = _Alter._1;
        const final_1 = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, node$2, _x$8, name2tag$2);
        const final_2 = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, node$2, _x$9, name2tag$2);
        const final_$3 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, final_1, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), final_$3);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, final_2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, moonbitlang$lex$lib$automaton$$NFA$add_edge$46$tag$46$default(), final_$3);
        return final_$3;
      }
      case 9: {
        const _Capture = re$2;
        const _x$10 = _Capture._0;
        const _x$11 = _Capture._1;
        const start = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        const final_$4 = moonbitlang$lex$lib$automaton$$NFA$new_node(self$2);
        const tail = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self$2, start, _x$10, name2tag$2);
        const _bind$2 = name2tag$2(_x$11);
        const _x$12 = _bind$2._0;
        const _x$13 = _bind$2._1;
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, node$2, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, _x$12, start);
        moonbitlang$lex$lib$automaton$$NFA$add_edge(self$2, tail, $64$moonbitlang$47$lex$47$lib$47$automaton$46$Input$Eps, _x$13, final_$4);
        return final_$4;
      }
      default: {
        return moonbitlang$core$builtin$$abort$41$("Named should be resolved before building NFA");
      }
    }
  }
}
function moonbitlang$lex$lib$automaton$$NFA$register_regex(self, node, re, code_block, name2tag) {
  const final_ = moonbitlang$lex$lib$automaton$$NFA$register_regex_rec(self, node, re, name2tag);
  const id = self.code_blocks.length;
  moonbitlang$core$array$$Array$push$6$(self.code_blocks, code_block);
  moonbitlang$core$builtin$$Map$set$47$(self.end_nodes, final_.num, id);
}
function moonbitlang$lex$lib$automaton$$NFA$from_rule(rule) {
  const nfa = moonbitlang$lex$lib$automaton$$NFA$new_nfa();
  const node = moonbitlang$lex$lib$automaton$$NFA$new_node(nfa);
  const _arr = rule.patterns;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const pattern = _arr[_i];
      const _x = pattern._0;
      const _x$2 = pattern._1;
      const capture_names = moonbitlang$core$array$$Array$map$127$(moonbitlang$lex$lib$type$$Regex$get_capture_names(_x), (name) => {
        const begin_tag = nfa.tag_count;
        const end_tag = nfa.tag_count + 1 | 0;
        nfa.tag_count = nfa.tag_count + 2 | 0;
        return { _0: name, _1: { _0: begin_tag, _1: end_tag } };
      });
      const map = moonbitlang$core$builtin$$Map$from_array$95$(capture_names);
      moonbitlang$lex$lib$automaton$$NFA$register_regex(nfa, node, _x, _x$2, (x) => moonbitlang$core$option$$Option$unwrap$61$(moonbitlang$core$builtin$$Map$get$95$(map, x)));
      moonbitlang$core$array$$Array$push$87$(nfa.captures, capture_names);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return nfa;
}
function moonbitlang$lex$lib$automaton$$DFA$from_rule(rule) {
  return moonbitlang$lex$lib$automaton$$DFA$from_nfa(moonbitlang$lex$lib$automaton$$NFA$from_rule(rule));
}
function moonbitlang$core$builtin$$Eq$op_equal$41$(self, other) {
  return self.num === other.num;
}
function moonbitlang$core$builtin$$Compare$compare$41$(self, other) {
  return $compare_int(self.num, other.num);
}
function moonbitlang$core$builtin$$Hash$hash_combine$41$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_0(input) {
  if (0 <= input && input <= 35) {
    return { _0: 1, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (input === 36) {
      return { _0: 2, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_1 };
    } else {
      if (37 <= input && input <= 122) {
        return { _0: 1, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        switch (input) {
          case 123: {
            return { _0: 4, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
          }
          case 124: {
            return { _0: 1, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
          }
          case 125: {
            return { _0: 3, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
          }
          default: {
            return 126 <= input && input <= 1114111 ? { _0: 1, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_1(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_2(input) {
  if (65 <= input && input <= 90) {
    return { _0: 5, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (input === 95) {
      return { _0: 5, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (97 <= input && input <= 100) {
        return { _0: 5, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (input === 101) {
          return { _0: 6, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
        } else {
          if (102 <= input && input <= 114) {
            return { _0: 5, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
          } else {
            if (input === 115) {
              return { _0: 7, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
            } else {
              return 116 <= input && input <= 122 ? { _0: 5, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
            }
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_3(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_4(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_5(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_6(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 109) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 110) {
            return { _0: 9, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 111 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_7(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 116) {
            return { _0: 10, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_8(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_9(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 99) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 100) {
            return { _0: 11, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 101 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_10(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      switch (input) {
        case 95: {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        }
        case 97: {
          return { _0: 12, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
        }
        default: {
          return 98 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_11(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 111) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 112) {
            return { _0: 13, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 113 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_12(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 113) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 114) {
            return { _0: 14, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 115 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_13(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 111) {
            return { _0: 15, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_14(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 116) {
            return { _0: 16, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_15(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 115) {
            return { _0: 17, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_3 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_16(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 111) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 112) {
            return { _0: 18, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 113 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_17(input) {
  if (input === 40) {
    return { _0: 19, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (65 <= input && input <= 90) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (input === 95) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_18(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 111) {
            return { _0: 20, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_2 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_19(input) {
  switch (input) {
    case 9: {
      return { _0: 22, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
    }
    case 32: {
      return { _0: 22, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
    }
    default: {
      if (65 <= input && input <= 90) {
        return { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
      } else {
        if (input === 95) {
          return { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_20(input) {
  if (48 <= input && input <= 57) {
    return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (input === 95) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          if (input === 115) {
            return { _0: 23, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_3 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_21(input) {
  switch (input) {
    case 9: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 32: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 41: {
      return { _0: 26, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_7 };
    }
    default: {
      if (48 <= input && input <= 57) {
        return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
        } else {
          if (input === 95) {
            return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
          } else {
            return 97 <= input && input <= 122 ? { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_22(input) {
  switch (input) {
    case 9: {
      return { _0: 22, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
    }
    case 32: {
      return { _0: 22, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
    }
    default: {
      if (65 <= input && input <= 90) {
        return { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
      } else {
        if (input === 95) {
          return { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 21, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_23(input) {
  if (input === 40) {
    return { _0: 19, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_4 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
    } else {
      if (65 <= input && input <= 90) {
        return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
      } else {
        if (input === 95) {
          return { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 8, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_0 } : { _0: -1, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_24(input) {
  switch (input) {
    case 9: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 32: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 41: {
      return { _0: 26, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_7 };
    }
    default: {
      if (48 <= input && input <= 57) {
        return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
        } else {
          if (input === 95) {
            return { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 };
          } else {
            return 97 <= input && input <= 122 ? { _0: 24, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_5 } : { _0: -1, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_25(input) {
  switch (input) {
    case 9: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 32: {
      return { _0: 25, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_6 };
    }
    case 41: {
      return { _0: 26, _1: moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_tag_action_7 };
    }
    default: {
      return { _0: -1, _1: [] };
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace_state_26(input) {
  return { _0: -1, _1: [] };
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace$147$(subst, lexbuf) {
  let _tmp = subst;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const subst$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$lex$45$runtime$lexengine$$LexEngine$run$146$(moonbitlang$lex$lib$codegen$internal$codeblock_parser$$__mbtlex_engine_scan_codeblock_rbrace, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace$147$(subst$2, lexbuf$2);
        continue _L;
      }
      case 1: {
        return;
      }
      case 2: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$3, _x$4);
        const _bind$3 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 1);
        const _x$5 = _bind$3._0;
        const _x$6 = _bind$3._1;
        const t1 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$5, _x$6);
        const _bind$4 = moonbitlang$core$array$$Array$op_get$61$(_x$2, 2);
        const _x$7 = _bind$4._0;
        const _x$8 = _bind$4._1;
        const t2 = moonbitlang$lex$45$runtime$lexbuf$$Lexbuf$sub_lexeme$146$(lexbuf$2, _x$7, _x$8);
        let _tmp$3;
        switch (t1) {
          case "startpos": {
            _tmp$3 = new $64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$StartPosOf(t2);
            break;
          }
          case "endpos": {
            _tmp$3 = new $64$moonbitlang$47$lex$47$lib$47$codegen$47$internal$47$codeblock_parser$46$SubstItemDesc$EndPosOf(t2);
            break;
          }
          default: {
            _tmp$3 = $panic();
          }
        }
        moonbitlang$core$array$$Array$push$119$(subst$2, { start: _x$3, end: _x$4, desc: _tmp$3 });
        continue _L;
      }
      case 3: {
        continue _L;
      }
      case 4: {
        continue _L;
      }
      case 5: {
        return;
      }
      default: {
        moonbitlang$core$builtin$$abort$4$("lex: fail to match");
        return;
      }
    }
  }
}
function moonbitlang$lex$lib$codegen$internal$codeblock_parser$$parse_codeblock(str) {
  const arg = moonbitlang$lex$45$runtime$lexbuf$$from_string$46$start$46$default();
  const arg$2 = moonbitlang$lex$45$runtime$lexbuf$$from_string$46$end$46$default(str);
  const lexbuf = moonbitlang$lex$45$runtime$lexbuf$$from_string(str, arg, arg$2);
  const subst = [];
  moonbitlang$lex$lib$codegen$internal$codeblock_parser$$scan_codeblock_rbrace$147$(subst, lexbuf);
  return subst;
}
function moonbitlang$lex$lib$codegen$$group_trans$46$42$func$153$(_env, _p) {
  const action = _env._2;
  const _x = _env._1;
  const _bind = _env._0;
  return _bind((_p$2) => {
    const _x$2 = _p$2._0;
    const _x$3 = _p$2._1;
    const _bind$2 = moonbitlang$lex$lib$util$eof_char_set$$EofChar$repr(_x$2);
    let _tmp;
    if (_bind$2.$tag === 0) {
      _tmp = -1;
    } else {
      const _Char = _bind$2;
      const _x$4 = _Char._0;
      _tmp = _x$4;
    }
    const _tmp$2 = _tmp;
    const _bind$3 = moonbitlang$lex$lib$util$eof_char_set$$EofChar$repr(_x$3);
    let _tmp$3;
    if (_bind$3.$tag === 0) {
      _tmp$3 = -1;
    } else {
      const _Char = _bind$3;
      const _x$4 = _Char._0;
      _tmp$3 = _x$4;
    }
    return _p({ _0: { _0: _tmp$2, _1: _tmp$3 }, _1: { _0: _x, _1: action } });
  });
}
function moonbitlang$lex$lib$codegen$$group_trans(trans) {
  const char_set_by_state = moonbitlang$core$builtin$$Map$from_array$98$([]);
  const tag_action_by_state = moonbitlang$core$builtin$$Map$from_array$99$([]);
  const _len = trans.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const tran = trans[_i];
      const _x = tran._0;
      const _x$2 = tran._1;
      const _x$3 = _x$2._0;
      const _x$4 = _x$2._1;
      moonbitlang$core$builtin$$Map$op_set$99$(tag_action_by_state, _x$3, _x$4);
      const _bind = moonbitlang$core$builtin$$Map$op_get$98$(char_set_by_state, _x$3);
      if (_bind === undefined) {
        moonbitlang$core$builtin$$Map$op_set$98$(char_set_by_state, _x$3, _x);
      } else {
        const _Some = _bind;
        const _x$5 = _Some;
        moonbitlang$core$builtin$$Map$op_set$98$(char_set_by_state, _x$3, moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$union(_x, _x$5));
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind = moonbitlang$core$builtin$$Map$iter$98$(char_set_by_state);
  const result = moonbitlang$core$builtin$$Iter$to_array$19$((_p) => _bind((_p$2) => {
    const _x = _p$2._0;
    const _x$2 = _p$2._1;
    const action = moonbitlang$core$option$$Option$unwrap$112$(moonbitlang$core$builtin$$Map$op_get$99$(tag_action_by_state, _x));
    const _bind$2 = moonbitlang$lex$lib$util$eof_char_set$$EofCharSet$iter_ranges(_x$2);
    const _env = { _0: _bind$2, _1: _x, _2: action };
    return moonbitlang$lex$lib$codegen$$group_trans$46$42$func$153$(_env, _p);
  }));
  moonbitlang$core$array$$Array$sort$19$(result);
  return result;
}
function moonbitlang$lex$lib$codegen$$rewrite_codeblock(codeblock, subst) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  let last_index = 0;
  const _len = subst.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const item = subst[_i];
      moonbitlang$core$builtin$$Logger$write_substring$12$(buf, codeblock, last_index, item.start - last_index | 0);
      const _bind = item.desc;
      if (_bind.$tag === 0) {
        const _StartPosOf = _bind;
        const _x = _StartPosOf._0;
        moonbitlang$core$builtin$$Logger$write_string$12$(buf, `_start_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(_x)}`);
      } else {
        const _EndPosOf = _bind;
        const _x = _EndPosOf._0;
        moonbitlang$core$builtin$$Logger$write_string$12$(buf, `_end_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(_x)}`);
      }
      last_index = item.end;
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (last_index < codeblock.length) {
    moonbitlang$core$builtin$$Logger$write_substring$12$(buf, codeblock, last_index, codeblock.length - last_index | 0);
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$lex$lib$codegen$$codegen_rule$46$get_tag_action_id$154$(_env, tag_action) {
  const next_tag_action_id = _env._1;
  const tag_action_dedup = _env._0;
  const _bind = moonbitlang$core$sorted_map$$T$op_get$50$(tag_action_dedup, tag_action);
  if (_bind === undefined) {
    const id = next_tag_action_id.val;
    moonbitlang$core$sorted_map$$T$op_set$50$(tag_action_dedup, tag_action, id);
    next_tag_action_id.val = next_tag_action_id.val + 1 | 0;
    return id;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$lex$lib$codegen$$codegen_rule(rule) {
  const dfa = moonbitlang$lex$lib$automaton$$DFA$from_rule(rule);
  const engine = `__mbtlex_engine_${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}`;
  const next_tag_action_row_id = { val: 0 };
  const tag_action_row_dedup = moonbitlang$core$sorted_map$$new$51$();
  const next_tag_action_id = { val: 0 };
  const tag_action_dedup = moonbitlang$core$sorted_map$$new$50$();
  const _env = { _0: tag_action_dedup, _1: next_tag_action_id };
  const states_code = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const graph_code = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Logger$write_string$12$(graph_code, "[");
  const _arr = dfa.graph;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const trans = _arr[_i];
      moonbitlang$core$builtin$$Logger$write_string$12$(states_code, `fn ${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_state_${moonbitlang$core$builtin$$Show$to_string$5$(_i)}(input : Int) -> (Int, Array[Array[Int]]) {\n  match input {\n`);
      const _arr$2 = moonbitlang$lex$lib$codegen$$group_trans(trans);
      const _len$2 = _arr$2.length;
      let _tmp$2 = 0;
      while (true) {
        const _i$2 = _tmp$2;
        if (_i$2 < _len$2) {
          const tran = _arr$2[_i$2];
          const _x = tran._0;
          const _x$2 = _x._0;
          const _x$3 = _x._1;
          const _x$4 = tran._1;
          const _x$5 = _x$4._0;
          const _x$6 = _x$4._1;
          if (_x$2 === _x$3) {
            moonbitlang$core$builtin$$Logger$write_string$12$(states_code, `    ${moonbitlang$core$builtin$$Show$to_string$5$(_x$2)} => (${moonbitlang$core$builtin$$Show$to_string$5$(_x$5)}, ${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_tag_action_${moonbitlang$core$builtin$$Show$to_string$5$(moonbitlang$lex$lib$codegen$$codegen_rule$46$get_tag_action_id$154$(_env, _x$6))})\n`);
          } else {
            moonbitlang$core$builtin$$Logger$write_string$12$(states_code, `    ${moonbitlang$core$builtin$$Show$to_string$5$(_x$2)}..=${moonbitlang$core$builtin$$Show$to_string$5$(_x$3)} => (${moonbitlang$core$builtin$$Show$to_string$5$(_x$5)}, ${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_tag_action_${moonbitlang$core$builtin$$Show$to_string$5$(moonbitlang$lex$lib$codegen$$codegen_rule$46$get_tag_action_id$154$(_env, _x$6))})\n`);
          }
          _tmp$2 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$12$(states_code, "    _ => (-1, [])\n");
      moonbitlang$core$builtin$$Logger$write_string$12$(states_code, "  }\n}\n");
      moonbitlang$core$builtin$$Logger$write_string$12$(graph_code, `${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_state_${moonbitlang$core$builtin$$Show$to_string$5$(_i)}, `);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$12$(graph_code, "]");
  const end_nodes = moonbitlang$core$array$$Array$makei$22$(dfa.node_count, (i) => moonbitlang$core$builtin$$Map$get$97$(dfa.end_nodes, i));
  const shared_tag_actions_code = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const _bind = moonbitlang$core$sorted_map$$T$iter2$50$(tag_action_dedup);
  _bind((tag_action, id) => {
    const rows_code = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
    moonbitlang$core$builtin$$Logger$write_string$12$(rows_code, "[");
    const _len$2 = tag_action.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const row = tag_action[_i];
        if (_i > 0) {
          moonbitlang$core$builtin$$Logger$write_string$12$(rows_code, ", ");
        }
        const _tmp$3 = moonbitlang$core$builtin$$Show$to_string$6$(rule.name);
        const _bind$2 = moonbitlang$core$sorted_map$$T$op_get$51$(tag_action_row_dedup, row);
        let _tmp$4;
        if (_bind$2 === undefined) {
          const id$2 = next_tag_action_row_id.val;
          moonbitlang$core$sorted_map$$T$op_set$51$(tag_action_row_dedup, row, id$2);
          next_tag_action_row_id.val = next_tag_action_row_id.val + 1 | 0;
          _tmp$4 = id$2;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          _tmp$4 = _x;
        }
        moonbitlang$core$builtin$$Logger$write_string$12$(rows_code, `${_tmp$3}_tag_action_row_${moonbitlang$core$builtin$$Show$to_string$5$(_tmp$4)}`);
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$builtin$$Logger$write_string$12$(rows_code, "]");
    moonbitlang$core$builtin$$Logger$write_string$12$(shared_tag_actions_code, `let ${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_tag_action_${moonbitlang$core$builtin$$Show$to_string$5$(id)} : Array[Array[Int]] = ${moonbitlang$core$builtin$$Show$to_string$137$(rows_code)}\n`);
    return 1;
  });
  const start_tags = [];
  const _arr$2 = dfa.start_action;
  const _len$2 = _arr$2.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const action = _arr$2[_i];
      if (!moonbitlang$core$array$$Array$is_empty$5$(action)) {
        moonbitlang$core$array$$Array$push$5$(start_tags, _i);
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const shared_tag_action_rows_code = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const _bind$2 = moonbitlang$core$sorted_map$$T$iter2$51$(tag_action_row_dedup);
  _bind$2((tag_action_row, id) => {
    moonbitlang$core$builtin$$Logger$write_string$12$(shared_tag_action_rows_code, `let ${moonbitlang$core$builtin$$Show$to_string$6$(rule.name)}_tag_action_row_${moonbitlang$core$builtin$$Show$to_string$5$(id)} : Array[Int] = ${moonbitlang$core$builtin$$Show$to_string$139$(tag_action_row)}\n`);
    return 1;
  });
  const _tmp$3 = moonbitlang$core$builtin$$StringBuilder$to_string(shared_tag_action_rows_code);
  const _tmp$4 = moonbitlang$core$builtin$$StringBuilder$to_string(shared_tag_actions_code);
  const _tmp$5 = moonbitlang$core$builtin$$StringBuilder$to_string(states_code);
  const _tmp$6 = `let ${moonbitlang$core$builtin$$Show$to_string$6$(engine)}: @lexengine.T = { graph: ${moonbitlang$core$builtin$$Show$to_string$137$(graph_code)}, end_nodes: ${moonbitlang$core$builtin$$Show$to_string$138$(end_nodes)}, start_tags: ${moonbitlang$core$builtin$$Show$to_string$139$(start_tags)}, code_blocks_n: ${moonbitlang$core$builtin$$Show$to_string$5$(dfa.code_blocks.length)} }`;
  const _lhs = [`fn ${moonbitlang$core$builtin$$Show$to_string$6$(rule.signature)} {`];
  const _tmp$7 = moonbitlang$core$string$$String$concat(_lhs, " ");
  const _lhs$2 = moonbitlang$core$array$$Array$flatten$6$([[`  match ${moonbitlang$core$builtin$$Show$to_string$6$(engine)}.run(lexbuf) {`], moonbitlang$core$array$$Array$makei$6$(dfa.code_blocks.length, (i) => {
    const codeblock = moonbitlang$core$array$$Array$op_get$6$(dfa.code_blocks, i);
    const subst = moonbitlang$lex$lib$codegen$internal$codeblock_parser$$parse_codeblock(codeblock);
    const _lhs$3 = moonbitlang$core$array$$Array$flatten$6$([[`    (${moonbitlang$core$builtin$$Show$to_string$5$(i)}, __mbtlex_captures) => {`], moonbitlang$core$array$$Array$mapi$141$(moonbitlang$core$array$$Array$op_get$90$(dfa.captures, i), (i$2, name) => {
      let inject_ignore;
      let _tmp$8;
      let _return_value;
      _L: {
        _L$2: {
          const _len$3 = subst.length;
          let _tmp$9 = 0;
          while (true) {
            const _i = _tmp$9;
            if (_i < _len$3) {
              const item = subst[_i];
              let n;
              _L$3: {
                const _bind$3 = item.desc;
                if (_bind$3.$tag === 0) {
                  const _StartPosOf = _bind$3;
                  const _x = _StartPosOf._0;
                  n = _x;
                  break _L$3;
                } else {
                  const _EndPosOf = _bind$3;
                  const _x = _EndPosOf._0;
                  n = _x;
                  break _L$3;
                }
              }
              if (n === name) {
                _return_value = true;
                break _L$2;
              }
              _tmp$9 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          _tmp$8 = false;
          break _L;
        }
        _tmp$8 = _return_value;
      }
      if (_tmp$8) {
        inject_ignore = `ignore(${moonbitlang$core$builtin$$Show$to_string$6$(name)})`;
      } else {
        inject_ignore = "";
      }
      return `  let (_start_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(name)}, _end_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(name)}) = __mbtlex_captures[${moonbitlang$core$builtin$$Show$to_string$5$(i$2)}]\n  let ${moonbitlang$core$builtin$$Show$to_string$6$(name)} = lexbuf.sub_lexeme(_start_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(name)}, _end_pos_of_${moonbitlang$core$builtin$$Show$to_string$6$(name)})\n  ${moonbitlang$core$builtin$$Show$to_string$6$(inject_ignore)}`;
    }), [moonbitlang$lex$lib$codegen$$rewrite_codeblock(codeblock, subst)], ["    }"]]);
    return moonbitlang$core$string$$String$concat(_lhs$3, "\n");
  }), ["    _ => abort(\"lex: fail to match\")"], ["  }"]]);
  const _lhs$3 = [_tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, moonbitlang$core$string$$String$concat(_lhs$2, "\n"), "}"];
  return moonbitlang$core$string$$String$concat(_lhs$3, "\n");
}
function moonbitlang$lex$lib$codegen$$codegen_lex(lex) {
  const _tmp = lex.header;
  const _lhs = moonbitlang$core$array$$Array$map$129$(lex.rules, moonbitlang$lex$lib$codegen$$codegen_rule);
  const _tmp$2 = moonbitlang$core$string$$String$concat(_lhs, "\n");
  const _lhs$2 = [_tmp, _tmp$2, lex.trailer];
  return moonbitlang$core$string$$String$concat(_lhs$2, "\n\n");
}
function Yoorkin$trie$$T$lookup$155$(self, path) {
  const _bind = moonbitlang$core$string$$String$to_array(path);
  let _tmp = { buf: _bind, start: 0, len: _bind.length };
  let _tmp$2 = self;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param.len === 0) {
      return _param$2.value;
    } else {
      const _x = _param.buf[_param.start + 0 | 0];
      const _tmp$3 = _param.buf;
      const _tmp$4 = 1 + _param.start | 0;
      const _some = _param.len - 0 | 0;
      const _x$2 = { buf: _tmp$3, start: _tmp$4, len: _some - 1 | 0 };
      const _bind$2 = moonbitlang$core$immut$sorted_map$$T$op_get$34$(_param$2.forks, _x);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$2;
        const _x$3 = _Some;
        _tmp = _x$2;
        _tmp$2 = _x$3;
        continue;
      }
    }
  }
}
function Yoorkin$trie$$T$add$155$(self, path, value) {
  const _bind = moonbitlang$core$string$$String$to_array(path);
  return Yoorkin$trie$$add$46$aux$47$4412(value, { buf: _bind, start: 0, len: _bind.length }, self);
}
function Yoorkin$trie$$add$46$aux$47$4412(value, _param1, _param2) {
  if (_param1.len === 0) {
    return { value: value, forks: _param2.forks };
  } else {
    const _x = _param1.buf[_param1.start + 0 | 0];
    const _tmp = _param1.buf;
    const _tmp$2 = 1 + _param1.start | 0;
    const _some = _param1.len - 0 | 0;
    const _x$2 = { buf: _tmp, start: _tmp$2, len: _some - 1 | 0 };
    const subtree = moonbitlang$core$option$$Option$or$48$(moonbitlang$core$immut$sorted_map$$T$op_get$34$(_param2.forks, _x), { value: undefined, forks: moonbitlang$core$immut$sorted_map$$new$34$() });
    return { value: _param2.value, forks: moonbitlang$core$immut$sorted_map$$T$add$34$(_param2.forks, _x, Yoorkin$trie$$add$46$aux$47$4412(value, _x$2, subtree)) };
  }
}
function Yoorkin$trie$$empty$155$() {
  return { value: undefined, forks: moonbitlang$core$immut$sorted_map$$new$34$() };
}
function Yoorkin$ArgParser$$interpret(trie, xs, fallback) {
  const _bind = 0;
  const _bind$2 = xs.length;
  let _tmp = xs;
  let _tmp$2 = _bind;
  let _tmp$3 = _bind$2;
  _L: while (true) {
    const _param_buf = _tmp;
    const _param_start = _tmp$2;
    const _param_len = _tmp$3;
    if (_param_len === 0) {
      return;
    } else {
      const _x = _param_buf[_param_start + 0 | 0];
      const _bind$3 = 1 + _param_start | 0;
      const _some = _param_len - 0 | 0;
      const _bind$4 = _some - 1 | 0;
      const _bind$5 = Yoorkin$trie$$T$lookup$155$(trie, _x);
      if (_bind$5 === undefined) {
        fallback(_x);
        _tmp$2 = _bind$3;
        _tmp$3 = _bind$4;
        continue;
      } else {
        const _Some = _bind$5;
        const _x$2 = _Some;
        _L$2: {
          switch (_x$2.$tag) {
            case 1: {
              const _String = _x$2;
              const _x$3 = _String._0;
              if (_bind$4 >= 1) {
                const _x$4 = _param_buf[_bind$3 + 0 | 0];
                const _bind$6 = 1 + _bind$3 | 0;
                const _some$2 = _bind$4 - 0 | 0;
                const _bind$7 = _some$2 - 1 | 0;
                _x$3(_x$4);
                _tmp$2 = _bind$6;
                _tmp$3 = _bind$7;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 2: {
              const _Set_string = _x$2;
              const _x$4 = _Set_string._0;
              if (_bind$4 >= 1) {
                const _x$5 = _param_buf[_bind$3 + 0 | 0];
                const _bind$6 = 1 + _bind$3 | 0;
                const _some$2 = _bind$4 - 0 | 0;
                const _bind$7 = _some$2 - 1 | 0;
                _x$4.val = _x$5;
                _tmp$2 = _bind$6;
                _tmp$3 = _bind$7;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 3: {
              const _Set = _x$2;
              const _x$5 = _Set._0;
              _x$5.val = true;
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
            case 4: {
              const _Clear = _x$2;
              const _x$6 = _Clear._0;
              _x$6.val = false;
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
            default: {
              const _Unit = _x$2;
              const _x$7 = _Unit._0;
              _x$7();
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
          }
        }
        moonbitlang$core$builtin$$println$6$(`missing argument for ${moonbitlang$core$builtin$$Show$to_string$6$(_x)}`);
        return;
      }
    }
  }
}
function Yoorkin$ArgParser$$parse$46$aux$156$(_param1, _param2) {
  const _x = _param1._0;
  const _x$2 = _param1._1;
  const _x$3 = _param2._0;
  const _x$4 = _param2._1;
  const _x$5 = _param2._2;
  const _x$6 = _param2._3;
  const trie = Yoorkin$trie$$T$add$155$(Yoorkin$trie$$T$add$155$(_x, _x$3, _x$5), _x$4, _x$5);
  const help_msg = `${_x$2}  ${moonbitlang$core$builtin$$Show$to_string$6$(_x$3)}\t${moonbitlang$core$builtin$$Show$to_string$6$(_x$4)}\t${_x$6}\n`;
  return { _0: trie, _1: help_msg };
}
function Yoorkin$ArgParser$$parse(speclist, rest, usage_msg, argv) {
  const _bind = moonbitlang$core$array$$Array$fold$142$(speclist, { _0: Yoorkin$trie$$empty$155$(), _1: `${usage_msg}\n options:\n` }, Yoorkin$ArgParser$$parse$46$aux$156$);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  const help_spec = new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    moonbitlang$core$builtin$$println$6$(_x$2);
  });
  const trie = Yoorkin$trie$$T$add$155$(Yoorkin$trie$$T$add$155$(_x, "--help", help_spec), "-h", help_spec);
  Yoorkin$ArgParser$$interpret(trie, argv, rest);
}
function moonbitlang$x$internal$ffi$$mbt_string_to_utf8_bytes(str, is_filename) {
  const res = [];
  const len = str.length;
  let i = 0;
  while (true) {
    if (i < len) {
      let c = str.charCodeAt(i);
      if (55296 <= c && c <= 56319) {
        c = c - 55296 | 0;
        i = i + 1 | 0;
        const l = str.charCodeAt(i) - 56320 | 0;
        c = ((c << 10) + l | 0) + 65536 | 0;
      }
      if (c < 128) {
        moonbitlang$core$array$$Array$push$7$(res, c & 255);
      } else {
        if (c < 2048) {
          moonbitlang$core$array$$Array$push$7$(res, (192 + (c >> 6) | 0) & 255);
          moonbitlang$core$array$$Array$push$7$(res, (128 + (c & 63) | 0) & 255);
        } else {
          if (c < 65536) {
            moonbitlang$core$array$$Array$push$7$(res, (224 + (c >> 12) | 0) & 255);
            moonbitlang$core$array$$Array$push$7$(res, (128 + (c >> 6 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$7$(res, (128 + (c & 63) | 0) & 255);
          } else {
            moonbitlang$core$array$$Array$push$7$(res, (240 + (c >> 18) | 0) & 255);
            moonbitlang$core$array$$Array$push$7$(res, (128 + (c >> 12 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$7$(res, (128 + (c >> 6 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$7$(res, (128 + (c & 63) | 0) & 255);
          }
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (is_filename) {
    moonbitlang$core$array$$Array$push$7$(res, 0 & 255);
  }
  return moonbitlang$core$bytes$$Bytes$from_array(res);
}
function moonbitlang$x$internal$ffi$$utf8_bytes_to_mbt_string(bytes) {
  const res = [];
  const len = bytes.length;
  let i = 0;
  while (true) {
    if (i < len) {
      let c = bytes[i];
      if (c < 128) {
        moonbitlang$core$array$$Array$push$11$(res, c);
        i = i + 1 | 0;
      } else {
        if (c < 224) {
          if ((i + 1 | 0) >= len) {
            break;
          }
          c = (c & 31) << 6 | bytes[i + 1 | 0] & 63;
          moonbitlang$core$array$$Array$push$11$(res, c);
          i = i + 2 | 0;
        } else {
          if (c < 240) {
            if ((i + 2 | 0) >= len) {
              break;
            }
            c = (c & 15) << 12 | (bytes[i + 1 | 0] & 63) << 6 | bytes[i + 2 | 0] & 63;
            moonbitlang$core$array$$Array$push$11$(res, c);
            i = i + 3 | 0;
          } else {
            if ((i + 3 | 0) >= len) {
              break;
            }
            c = (c & 7) << 18 | (bytes[i + 1 | 0] & 63) << 12 | (bytes[i + 2 | 0] & 63) << 6 | bytes[i + 3 | 0] & 63;
            c = c - 65536 | 0;
            moonbitlang$core$array$$Array$push$11$(res, (c >> 10) + 55296 | 0);
            moonbitlang$core$array$$Array$push$11$(res, (c & 1023) + 56320 | 0);
            i = i + 4 | 0;
          }
        }
      }
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$string$$String$from_array(res);
}
function moonbitlang$x$sys$internal$ffi$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args_internal();
}
function moonbitlang$x$sys$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args();
}
function moonbitlang$x$fs$$read_file_to_bytes_internal(path) {
  const res = moonbitlang$x$fs$$read_file_ffi(path);
  if (res === -1) {
    return new Result$Err$21$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(moonbitlang$x$fs$$get_error_message_ffi()));
  }
  return new Result$Ok$22$(moonbitlang$x$fs$$get_file_content_ffi());
}
function moonbitlang$x$fs$$read_file_to_string_internal(path, encoding) {
  if (encoding === "utf8") {
    const _bind = moonbitlang$x$fs$$read_file_to_bytes_internal(path);
    let bytes;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      bytes = _ok._0;
    } else {
      return _bind;
    }
    return new Result$Ok$24$(moonbitlang$x$internal$ffi$$utf8_bytes_to_mbt_string(bytes));
  } else {
    return new Result$Err$23$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(`Unsupported encoding: ${moonbitlang$core$builtin$$Show$to_string$6$(encoding)}, only utf8 is supported for now`));
  }
}
function moonbitlang$x$fs$$write_bytes_to_file_internal(path, content) {
  const res = moonbitlang$x$fs$$write_file_ffi(path, content);
  if (res === -1) {
    return new Result$Err$26$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(moonbitlang$x$fs$$get_error_message_ffi()));
  } else {
    return new Result$Ok$25$(undefined);
  }
}
function moonbitlang$x$fs$$write_string_to_file_internal(path, content, encoding) {
  if (encoding === "utf8") {
    const bytes = moonbitlang$x$internal$ffi$$mbt_string_to_utf8_bytes(content, false);
    return moonbitlang$x$fs$$write_bytes_to_file_internal(path, bytes);
  } else {
    return new Result$Err$26$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(`Unsupported encoding: ${moonbitlang$core$builtin$$Show$to_string$6$(encoding)}, only utf8 is supported for now`));
  }
}
function moonbitlang$x$fs$$read_file_to_string(path, encoding) {
  return moonbitlang$x$fs$$read_file_to_string_internal(path, encoding);
}
function moonbitlang$x$fs$$read_file_to_string$46$encoding$46$default() {
  return "utf8";
}
function moonbitlang$x$fs$$write_string_to_file(path, content, encoding) {
  return moonbitlang$x$fs$$write_string_to_file_internal(path, content, encoding);
}
function moonbitlang$x$fs$$write_string_to_file$46$encoding$46$default() {
  return "utf8";
}
(() => {
  const output_file = moonbitlang$core$ref$$new$6$("");
  const input_file = moonbitlang$core$ref$$new$6$("");
  const exit = { val: false };
  Yoorkin$ArgParser$$parse([{ _0: "--output-file", _1: "-o", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Set_string(output_file), _3: "Output file" }, { _0: "--version", _1: "-v", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    exit.val = true;
    moonbitlang$core$builtin$$println$6$("moonlex 0.1.0");
  }), _3: "Show version" }], (rest) => {
    input_file.val = rest;
  }, moonbitlang$lex$main$$_init$42$46$usage$0$, moonbitlang$x$sys$$get_cli_args());
  if (exit.val) {
    return;
  }
  if (moonbitlang$core$builtin$$op_notequal$6$(input_file.val, "")) {
    const lexer_spec_src = moonbitlang$core$result$$Result$unwrap$15$(moonbitlang$x$fs$$read_file_to_string(input_file.val, moonbitlang$x$fs$$read_file_to_string$46$encoding$46$default()));
    let lex;
    let _try_err;
    _L: {
      _L$2: {
        const _bind = moonbitlang$lex$lib$parser$$parse_lex_from_string(lexer_spec_src);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          lex = _ok._0;
        } else {
          const _err = _bind;
          const _tmp = _err._0;
          _try_err = _tmp;
          break _L$2;
        }
        break _L;
      }
      moonbitlang$core$builtin$$println$85$(_try_err);
      lex = $panic();
    }
    const lex$2 = moonbitlang$lex$lib$type$$Lex$eliminate_named(lex);
    const output = moonbitlang$lex$lib$codegen$$codegen_lex(lex$2);
    if (output_file.val === "") {
      moonbitlang$core$builtin$$println$6$(output);
      return;
    } else {
      moonbitlang$core$result$$Result$unwrap$14$(moonbitlang$x$fs$$write_string_to_file(output_file.val, output, moonbitlang$x$fs$$write_string_to_file$46$encoding$46$default()));
      return;
    }
  } else {
    moonbitlang$core$builtin$$abort$4$("Input file is required");
    return;
  }
})();
